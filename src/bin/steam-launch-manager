#!/usr/bin/env python3
"""
Steam Launch Options Manager
智能管理 Steam 游戏启动参数，支持前置/后置参数合并和冲突处理
"""

import argparse
import logging
import subprocess
import sys
from datetime import datetime
from pathlib import Path
import re

import yaml

try:
    import vdf
except ImportError:
    print("Error: python-vdf library is required. Install with: pip install vdf")
    sys.exit(1)

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger('steam-launch-manager')

# =============================================================================
# 配置参数 - Configuration Parameters
# =============================================================================

APP_NAME = "steam-launch-manager"
INNER_DB_PATH = f"/usr/share/{APP_NAME}/data/games-db.yaml"
INNER_VERSION_PATH = f"/usr/share/{APP_NAME}/VERSION"

# Steam 启动参数占位符
COMMAND_PLACEHOLDER = "%command%"

# 社区数据库更新配置
COMMUNITY_DB_URLS = [
    "https://gitee.com/honjow/steam-launch-manager/raw/master/src/data/games-db.yaml",  # 镜像地址
    "https://raw.githubusercontent.com/honjow/steam-launch-manager/refs/heads/master/src/data/games-db.yaml",
    "https://cdn.jsdelivr.net/gh/honjow/steam-launch-manager@master/src/data/games-db.yaml",  # CDN镜像
]
VERSION_CHECK_URLS = [
    "https://gitee.com/honjow/steam-launch-manager/raw/master/src/data/VERSION",
    "https://raw.githubusercontent.com/honjow/steam-launch-manager/refs/heads/master/src/data/VERSION",
    "https://cdn.jsdelivr.net/gh/honjow/steam-launch-manager@master/src/data/VERSION",
]
UPDATE_CHECK_INTERVAL_HOURS = 1  # 检查更新间隔（小时）
NETWORK_TIMEOUT_SECONDS = 10  # 网络请求超时时间（秒）
USER_AGENT = "steam-launch-manager/1.0"  # 用户代理字符串

# 网络优化配置
NETWORK_QUICK_TIMEOUT = 2      # 快速网络检测超时
NETWORK_VERSION_TIMEOUT = 1    # 版本检查超时  
NETWORK_DOWNLOAD_TIMEOUT = 3   # 快速下载超时
NETWORK_RETRY_TIMEOUT = 5      # 重试时的超时

# 重试配置
RETRY_ATTEMPTS = 3             # 最大重试次数
RETRY_DELAY_BASE = 1           # 基础延迟（秒）
RETRY_DELAY_MAX = 8            # 最大延迟（秒）

# DNS服务器用于网络检测
NETWORK_TEST_HOSTS = [
    ('8.8.8.8', 53),           # Google DNS
    ('1.1.1.1', 53),           # Cloudflare DNS
    ('114.114.114.114', 53)    # 国内DNS
]

# 默认配置路径
DEFAULT_CONFIG_PATH = "~/.config/steam-launch-manager"
DEFAULT_STEAM_PATH = "~/.local/share/Steam"
DEFAULT_BACKUP_PATH = "~/.config/steam-backups"

# =============================================================================
# 启动选项类型定义 - Launch Option Types
# =============================================================================

LAUNCH_OPTION_TYPES = {
    "simple": "简单前置/后置参数",
    "script": "复杂Shell脚本",
    "template": "模板替换",
    "raw": "原始替换（不解析）"
}

class LaunchOptionHandler:
    """启动选项处理器 - 支持不同类型的启动选项"""
    
    def __init__(self):
        self.command_placeholder_pattern = re.compile(r'%command%', re.IGNORECASE)
    
    def detect_option_type(self, launch_options):
        """检测启动选项的类型"""
        if not launch_options:
            return "simple"
            
        # 检测复杂脚本模式
        script_indicators = [
            'eval $(',
            'ln -s',
            'IFS=:',
            '|', 
            '&&',
            '||',
            'for ',
            'if [',
            'sed "s/'
        ]
        
        if any(indicator in launch_options for indicator in script_indicators):
            return "script"
            
        # 检测模板替换
        if '${' in launch_options or '$(' in launch_options:
            return "template"
            
        # 默认为简单模式
        return "simple"
    
    def apply_config_by_type(self, current_options, game_config):
        """根据配置类型应用不同的处理逻辑"""
        config_type = game_config.get("type", "simple")
        
        if config_type == "raw":
            return self._apply_raw_config(current_options, game_config)
        elif config_type == "script":
            return self._apply_script_config(current_options, game_config)
        elif config_type == "template":
            return self._apply_template_config(current_options, game_config)
        else:
            return self._apply_simple_config(current_options, game_config)
    
    def _apply_raw_config(self, current_options, game_config):
        """原始替换模式 - 直接使用配置中的启动选项"""
        raw_options = game_config.get("raw_options", "")
        return raw_options
    
    def _apply_script_config(self, current_options, game_config):
        """脚本模式 - 保持复杂脚本的完整性"""
        script_template = game_config.get("script_template", "")
        
        # 对于脚本模式，我们通常不进行复杂的合并
        # 而是提供整个脚本作为启动选项
        if script_template:
            return script_template
        
        # 如果没有模板，回退到简单模式
        return self._apply_simple_config(current_options, game_config)
    
    def _apply_template_config(self, current_options, game_config):
        """模板模式 - 支持变量替换"""
        template = game_config.get("template", "")
        variables = game_config.get("variables", {})
        
        # 替换模板中的变量
        result = template
        for var_name, var_value in variables.items():
            result = result.replace(f"${{{var_name}}}", str(var_value))
        
        return result
    
    def _apply_simple_config(self, current_options, game_config):
        """简单模式 - 使用现有的前置/后置参数逻辑"""
        # 这个方法在主类中会被覆盖
        # 这里只是占位符，实际处理在 SteamLaunchManager 中
        return current_options

class SteamLaunchManager:
    def __init__(self, config_path=None):
        if config_path is None:
            config_path = DEFAULT_CONFIG_PATH

        self.config_dir = Path(config_path).expanduser()
        self.custom_config_path = self.config_dir / "custom" / "games.yaml"
        self.community_config_path = self.config_dir / "community" / "games.yaml"
        self.community_version_path = self.config_dir / "community" / "version.txt"

        # 初始化启动选项处理器
        self.launch_option_handler = LaunchOptionHandler()

        # 确保目录存在
        self.config_dir.mkdir(parents=True, exist_ok=True)
        (self.config_dir / "custom").mkdir(exist_ok=True)
        (self.config_dir / "community").mkdir(exist_ok=True)

        # 加载配置
        self.custom_config = self.load_custom_config()
        self.community_config = self.load_community_config()

        # 检查并应用内置版本更新
        self.check_inner_version_update()

        # 网络检查优化：严格控制时间
        import time
        start_time = time.time()
        try:
            # 检查社区配置更新（优化版本）
            self.check_community_updates()
        except Exception as e:
            logger.debug(f"Network check failed: {e}")
        
        # 记录初始化时间
        elapsed = time.time() - start_time
        if elapsed > 3.0:  # 如果超过3秒记录警告
            logger.warning(f"Network check took {elapsed:.1f}s, consider disabling auto-update")

        # 使用配置文件中的steam_dir，如果没有则使用默认值
        config_steam_dir = self.custom_config.get("global", {}).get("steam_dir")
        if config_steam_dir:
            self.steam_dir = Path(config_steam_dir).expanduser()
        else:
            self.steam_dir = Path(DEFAULT_STEAM_PATH).expanduser()

        self.backup_dir = Path(
            self.custom_config.get("global", {}).get("backup_path", DEFAULT_BACKUP_PATH)
        ).expanduser()

    def load_custom_config(self):
        """加载用户自定义配置"""
        if not self.custom_config_path.exists():
            self.create_default_custom_config()

        with open(self.custom_config_path) as f:
            return yaml.safe_load(f) or {}

    def load_community_config(self):
        """加载社区预设配置"""
        if not self.community_config_path.exists():
            return {"games": {}}

        with open(self.community_config_path) as f:
            return yaml.safe_load(f) or {"games": {}}

    def create_default_custom_config(self):
        """创建默认的用户自定义配置文件"""
        default_config = {
            "global": {
                "backup_enabled": True,
                "backup_path": DEFAULT_BACKUP_PATH,
                "dry_run": False,
                "auto_update_community_db": True,
                
                # 网络配置（可选）
                "network": {
                    "quick_timeout_seconds": 2,
                    "retry_attempts": 3,
                    "background_update": True
                }
            },
            "games": {
                # 用户可以在这里添加自己的游戏配置
                # 示例（可以删除）:
                # "730": {
                #     "name": "Counter-Strike 2 - Custom",
                #     "prefix": {
                #         "params": ["RADV_PERFTEST=aco"]
                #     }
                # }
            },
        }

        self.custom_config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.custom_config_path, "w") as f:
            yaml.dump(default_config, f, default_flow_style=False, indent=2)

        logger.info(f"Created custom config at: {self.custom_config_path}")
        return default_config

    def get_game_config(self, app_id, verbose=True):
        """获取游戏配置：用户配置优先于社区配置"""
        # 1. 检查用户自定义配置
        custom_games = self.custom_config.get("games", {})
        if app_id in custom_games:
            if verbose:
                logger.info(f"Using custom config for {app_id}")
            return custom_games[app_id], "custom"

        # 2. 使用社区预设配置
        community_games = self.community_config.get("games", {})
        if app_id in community_games:
            if verbose:
                logger.info(f"Using community config for {app_id}")
            return community_games[app_id], "community"

        # 3. 没有配置
        return None, None

    def check_inner_version_update(self):
        """检查内置版本并在版本更高时覆盖本地数据库"""
        try:
            inner_version = self._get_inner_version()
            if not inner_version:
                return
            
            local_version = self._get_local_version()
            
            # 比较版本
            if self._is_version_higher(inner_version, local_version):
                logger.info(f"发现更高版本的内置数据库: {inner_version} (当前: {local_version or '无'})")
                
                # 复制内置数据库到本地
                if self._copy_inner_database():
                    logger.info("内置数据库已成功覆盖本地配置")
                    
                    # 更新版本信息
                    self._update_version_info_for_inner(inner_version)
                    
                    # 重新加载社区配置
                    self.community_config = self.load_community_config()
                else:
                    logger.error("复制内置数据库失败")
            elif inner_version == local_version:
                logger.debug(f"内置数据库版本已是最新: {inner_version}")
        
        except Exception as e:
            logger.error(f"检查内置版本时出错: {e}")

    def _get_inner_version(self):
        """获取内置版本号"""
        try:
            inner_version_path = Path(INNER_VERSION_PATH)
            if inner_version_path.exists():
                with open(inner_version_path, 'r', encoding='utf-8') as f:
                    return f.read().strip()
        except Exception as e:
            logger.error(f"读取内置版本文件失败: {e}")
        return None

    def _is_version_higher(self, version1, version2):
        """比较版本号，返回 version1 是否高于 version2"""
        if not version2:  # 本地版本不存在，内置版本更高
            return True
        if not version1:  # 内置版本不存在
            return False
        
        try:
            # 将版本号转换为可比较的元组
            def version_tuple(v):
                return tuple(map(int, v.split('.')))
            
            return version_tuple(version1) > version_tuple(version2)
        except ValueError:
            # 如果版本号格式不正确，使用字符串比较
            return version1 > version2

    def _copy_inner_database(self):
        """复制内置数据库到本地社区配置"""
        try:
            inner_db_path = Path(INNER_DB_PATH)
            if not inner_db_path.exists():
                logger.error(f"内置数据库文件不存在: {inner_db_path}")
                return False
            
            # 确保目录存在
            self.community_config_path.parent.mkdir(parents=True, exist_ok=True)
            
            # 复制文件
            import shutil
            shutil.copy2(inner_db_path, self.community_config_path)
            
            return True
        except Exception as e:
            logger.error(f"复制内置数据库失败: {e}")
            return False

    def _update_version_info_for_inner(self, inner_version):
        """为内置数据库更新版本信息"""
        try:
            with open(self.community_version_path, "w", encoding="utf-8") as f:
                f.write(f"Updated: {datetime.now().isoformat()}\n")
                f.write(f"Source: inner_database\n")
                f.write(f"Version: {inner_version}\n")
        except Exception as e:
            logger.error(f"更新版本信息失败: {e}")

    def _quick_network_check(self, timeout=2):
        """快速网络连通性检测"""
        import socket
        
        for host, port in NETWORK_TEST_HOSTS:
            try:
                sock = socket.create_connection((host, port), timeout=timeout/len(NETWORK_TEST_HOSTS))
                sock.close()
                return True
            except:
                continue
        return False

    def check_community_updates(self):
        """检查并更新社区配置数据库 - 优化版本"""
        auto_update = self.custom_config.get("global", {}).get(
            "auto_update_community_db", True
        )
        if not auto_update:
            return

        # 快速检查阶段（同步，5秒内完成）
        quick_result = self._quick_update_check()
        
        if quick_result == "no_network":
            logger.debug("Network unavailable, using local cache")
            return
        elif quick_result == "up_to_date":
            logger.debug("Database is up to date")
            return
        elif quick_result == "need_download":
            # 启动异步后台下载
            self._start_background_download()

    def _quick_update_check(self):
        """快速更新检查 - 5秒内完成"""
        # 1. 网络连通性检测 (2秒)
        if not self._quick_network_check(timeout=NETWORK_QUICK_TIMEOUT):
            return "no_network"
        
        # 2. 快速版本检查 (1秒)  
        try:
            remote_version = self._get_remote_version_quick()
            local_version = self._get_local_version()
            
            if remote_version and local_version and remote_version == local_version:
                self._update_check_timestamp()
                return "up_to_date"
            else:
                return "need_download"
        except Exception as e:
            logger.debug(f"Quick version check failed: {e}")
            return "no_network"

    def _should_update_database(self):
        """检查是否应该更新数据库"""
        # 如果是强制更新，跳过时间检查但仍进行版本比较
        if hasattr(self, "_force_update") and self._force_update:
            return True

        # 如果社区配置不存在，需要更新
        if not self.community_config_path.exists():
            return True

        # 检查上次更新时间
        if not self.community_version_path.exists():
            return True

        try:
            import time

            # 获取文件最后修改时间
            last_modified = self.community_version_path.stat().st_mtime
            current_time = time.time()

            # 如果超过指定小时数没更新，则需要更新
            if current_time - last_modified > UPDATE_CHECK_INTERVAL_HOURS * 3600:
                return True

        except Exception:
            return True

        return False

    def _get_remote_version_quick(self):
        """快速获取远程版本信息"""
        import urllib.error
        import urllib.request

        for url in VERSION_CHECK_URLS:
            try:
                request = urllib.request.Request(url)
                request.add_header("User-Agent", USER_AGENT)

                with urllib.request.urlopen(
                    request, timeout=NETWORK_VERSION_TIMEOUT
                ) as response:
                    version = response.read().decode("utf-8").strip()
                    if version:
                        return version
            except (urllib.error.URLError, Exception):
                continue
        return None

    def _get_remote_version(self):
        """获取远程版本信息"""
        import urllib.error
        import urllib.request

        for url in VERSION_CHECK_URLS:
            try:
                request = urllib.request.Request(url)
                request.add_header("User-Agent", USER_AGENT)

                with urllib.request.urlopen(
                    request, timeout=NETWORK_TIMEOUT_SECONDS
                ) as response:
                    version = response.read().decode("utf-8").strip()
                    if version:
                        return version
            except (urllib.error.URLError, Exception):
                continue
        return None

    def _get_local_version(self):
        """获取本地版本信息"""
        try:
            if self.community_version_path.exists():
                with open(self.community_version_path, "r") as f:
                    lines = f.readlines()
                    for line in lines:
                        if line.startswith("Version: "):
                            return line.split("Version: ", 1)[1].strip()
        except Exception:
            pass
        return None

    def _start_background_download(self):
        """启动后台下载线程"""
        import threading
        
        def background_worker():
            # 等待一段时间，确保主程序已经启动完成
            import time
            time.sleep(30)  # 30秒后开始后台更新
            
            logger.info("Starting background database update...")
            success = self._download_with_retry()
            if success:
                logger.info("Background database update completed")
                # 重新加载配置（为下次使用准备）
                self.community_config = self.load_community_config()
            else:
                logger.debug("Background database update failed")
        
        # 创建守护线程
        thread = threading.Thread(target=background_worker, daemon=True)
        thread.start()
        logger.debug("Background update scheduled")

    def _download_with_retry(self):
        """带重试机制的下载"""
        import time
        
        for attempt in range(RETRY_ATTEMPTS):
            # 指数退避延迟
            if attempt > 0:
                delay = min(RETRY_DELAY_BASE * (2 ** (attempt - 1)), RETRY_DELAY_MAX)
                logger.debug(f"Retry attempt {attempt}, waiting {delay}s...")
                time.sleep(delay)
            
            # 每次重试前检查网络
            if not self._quick_network_check(timeout=1):
                logger.debug(f"Network unavailable on attempt {attempt + 1}")
                continue
                
            # 尝试下载
            timeout = NETWORK_RETRY_TIMEOUT if attempt > 0 else NETWORK_DOWNLOAD_TIMEOUT
            success, db_url, content = self._download_database_with_timeout(timeout)
            
            if success and content:
                try:
                    yaml.safe_load(content)
                    with open(self.community_config_path, "w", encoding="utf-8") as f:
                        f.write(content)
                    self._update_version_info(db_url)
                    return True
                except Exception as e:
                    logger.error(f"Failed to save downloaded content: {e}")
                    continue
        
        return False

    def _download_database_with_timeout(self, timeout):
        """带超时控制的数据库下载"""
        import urllib.error
        import urllib.request
        
        for url in COMMUNITY_DB_URLS:
            try:
                logger.debug(f"Downloading from: {url} (timeout: {timeout}s)")
                request = urllib.request.Request(url)
                request.add_header("User-Agent", USER_AGENT)
                
                with urllib.request.urlopen(request, timeout=timeout) as response:
                    content = response.read().decode("utf-8")
                    logger.debug(f"Successfully downloaded from: {url}")
                    return True, url, content
                    
            except urllib.error.URLError as e:
                logger.debug(f"URL error from {url}: {e}")
                continue
            except Exception as e:
                logger.debug(f"Download error from {url}: {e}")
                continue
        
        return False, None, None

    def _download_database(self):
        """尝试从镜像地址下载数据库"""
        import urllib.error
        import urllib.request

        for url in COMMUNITY_DB_URLS:
            try:
                logger.debug(f"Trying to download from: {url}")
                request = urllib.request.Request(url)
                request.add_header("User-Agent", USER_AGENT)

                with urllib.request.urlopen(
                    request, timeout=NETWORK_TIMEOUT_SECONDS
                ) as response:
                    content = response.read().decode("utf-8")
                    logger.debug(f"Successfully downloaded from: {url}")
                    return True, url, content
            except urllib.error.URLError as e:
                logger.debug(f"Failed to download from {url}: {e}")
                continue
            except Exception as e:
                logger.debug(f"Error downloading from {url}: {e}")
                continue

        return False, None, None

    def _update_check_timestamp(self):
        """更新检查时间戳而不修改版本信息"""
        try:
            # 如果版本文件存在，只更新时间戳
            if self.community_version_path.exists():
                import os
                import time

                current_time = time.time()
                os.utime(self.community_version_path, (current_time, current_time))
        except Exception as e:
            logger.error(f"Failed to update timestamp: {e}")

    def _update_version_info(self, source_url, version=None):
        """更新版本信息"""
        try:
            with open(self.community_version_path, "w") as f:
                f.write(f"Updated: {datetime.now().isoformat()}\n")
                f.write(f"Source: {source_url}\n")
                if version:
                    f.write(f"Version: {version}\n")
                else:
                    f.write(f"Version: {datetime.now().strftime('%Y.%m.%d')}\n")
        except Exception as e:
            logger.error(f"Failed to update version info: {e}")

    def force_update_community_db(self):
        """强制更新社区数据库，忽略时间检查"""
        # 标记为强制更新，跳过时间检查但保留版本比较
        self._force_update = True
        try:
            self.check_community_updates()
        finally:
            self._force_update = False

    def is_steam_running(self):
        """检查 Steam 是否正在运行"""
        try:
            result = subprocess.run(
                ["pgrep", "-x", "steam"], capture_output=True, text=True
            )
            return result.returncode == 0
        except Exception as e:
            logger.error(f"Error checking if Steam is running: {e}")
            return False

    def get_steam_user_dirs(self):
        """获取所有 Steam 用户目录"""
        userdata_dir = self.steam_dir / "userdata"
        if not userdata_dir.exists():
            return []
        return [d for d in userdata_dir.iterdir() if d.is_dir() and d.name.isdigit()]

    def load_vdf_file(self, file_path):
        """安全加载VDF文件，支持文本和二进制格式"""
        try:
            # 先尝试文本格式
            with open(file_path, "r", encoding="utf-8") as f:
                return vdf.load(f), "text"
        except (UnicodeDecodeError, Exception):
            try:
                # 再尝试二进制格式
                with open(file_path, "rb") as f:
                    return vdf.binary_load(f), "binary"
            except Exception as e:
                raise Exception(f"Failed to parse VDF file {file_path}: {e}")

    def save_vdf_file(self, file_path, data, format_type):
        """保存VDF文件，保持原格式"""
        if format_type == "text":
            with open(file_path, "w", encoding="utf-8") as f:
                vdf.dump(data, f, pretty=True)
        else:
            with open(file_path, "wb") as f:
                f.write(vdf.binary_dumps(data))

    def parse_current_params(self, current_options):
        """解析当前启动参数为前置和后置部分
        
        支持大小写不敏感的 %command% 占位符检测
        Steam 中可能出现 %command%、%COMMAND% 等不同大小写形式
        """
        if not current_options:
            return [], ""

        # 查找 %command% 占位符（大小写不敏感）
        # Steam 可能使用不同大小写的 %command%，如 %COMMAND%
        command_pattern = re.compile(r'%command%', re.IGNORECASE)
        match = command_pattern.search(current_options)
        
        if not match:
            # 如果没有找到 %command% 占位符，将整个字符串视为后置参数
            return [], current_options.strip()

        # 使用找到的实际占位符进行分割
        command_placeholder = match.group()
        parts = current_options.split(command_placeholder, 1)
        prefix_part = parts[0].strip()
        suffix_part = parts[1].strip() if len(parts) > 1 else ""

        prefix_params = prefix_part.split() if prefix_part else []
        return prefix_params, suffix_part

    def are_configs_equivalent(self, current_options, new_options):
        """检查两个配置是否实质相同（忽略仅添加%command%的情况）"""
        if current_options == new_options:
            return True
        
        # 规范化处理（去除多余空格，统一%command%格式）
        def normalize_config(config):
            if not config:
                return ""
            # 规范化%command%周围的空格
            normalized = re.sub(r'\s*%command%\s*', ' %command% ', config, flags=re.IGNORECASE)
            # 清理多余空格
            normalized = ' '.join(normalized.split())
            return normalized.strip()
        
        normalized_current = normalize_config(current_options)
        normalized_new = normalize_config(new_options)
        
        if normalized_current == normalized_new:
            return True
        
        # 解析两个配置
        curr_prefix, curr_suffix = self.parse_current_params(current_options)
        new_prefix, new_suffix = self.parse_current_params(new_options)
        
        # 如果前置参数为空且后置参数相同，视为等价
        if not curr_prefix and not new_prefix and curr_suffix == new_suffix:
            return True
            
        # 特殊情况：当前没有%command%，新配置只是添加了%command%但参数内容相同
        if not current_options.strip():
            return new_options == COMMAND_PLACEHOLDER
        
        if COMMAND_PLACEHOLDER not in current_options and COMMAND_PLACEHOLDER in new_options:
            # 检查是否只是在相同内容前添加了%command%
            expected_new = f"{COMMAND_PLACEHOLDER} {current_options}".strip()
            if new_options == expected_new:
                return True
        
        return False


    def merge_prefix_params(self, user_prefix, config_prefix, user_handling, conflicts):
        """合并前置参数"""
        managed_params = config_prefix.get("params", [])
        preserve = user_handling.get("preserve", True)
        position = user_handling.get("position", "before")

        if not preserve:
            return managed_params

        # 处理冲突规则
        final_user_params = user_prefix.copy()
        replace_keys = conflicts.get("replace_keys", [])
        merge_keys = conflicts.get("merge_keys", {})

        # 构建环境变量字典用于冲突处理
        user_env = {}
        managed_env = {}

        # 解析用户的环境变量
        user_non_env = []
        for param in final_user_params:
            if "=" in param and not param.startswith("-"):
                key, value = param.split("=", 1)
                user_env[key] = value
            else:
                user_non_env.append(param)

        # 解析管理的环境变量
        managed_non_env = []
        for param in managed_params:
            if "=" in param and not param.startswith("-"):
                key, value = param.split("=", 1)
                managed_env[key] = value
            else:
                managed_non_env.append(param)

        # 处理环境变量冲突
        final_env = user_env.copy()

        # 替换规则：强制使用管理的值
        for key in replace_keys:
            if key in managed_env:
                final_env[key] = managed_env[key]

        # 添加管理的新环境变量
        for key, value in managed_env.items():
            if key not in final_env:
                final_env[key] = value

        # 处理路径合并
        for key, merge_type in merge_keys.items():
            if key in managed_env and key in user_env:
                if merge_type == "prepend":
                    final_env[key] = f"{managed_env[key]}:{user_env[key]}"
                elif merge_type == "append":
                    final_env[key] = f"{user_env[key]}:{managed_env[key]}"

        # 重建参数列表
        env_params = [f"{k}={v}" for k, v in final_env.items()]

        if position == "before":
            all_params = env_params + user_non_env + managed_non_env
        elif position == "after":
            all_params = managed_non_env + env_params + user_non_env
        else:  # replace
            all_params = env_params + managed_non_env
        
        # 去重但保持顺序（对非环境变量参数）
        final_params = []
        seen = set()
        for param in all_params:
            if param not in seen:
                final_params.append(param)
                seen.add(param)
        
        return final_params

    def merge_suffix_params(self, user_suffix, config_suffix, user_handling, conflicts):
        """合并后置参数"""
        managed_params = config_suffix.get("params", [])
        preserve = user_handling.get("preserve", True)
        position = user_handling.get("position", "before")

        user_params = user_suffix.split() if user_suffix else []

        if not preserve:
            final_params = managed_params
        else:
            # 处理替换规则
            replace_rules = conflicts.get("replace_rules", {})
            processed_user_params = []

            for param in user_params:
                if param in replace_rules:
                    replacement = replace_rules[param]
                    if replacement:  # 如果替换值不为空
                        processed_user_params.append(replacement)
                    # 如果替换值为空，则跳过（删除该参数）
                else:
                    processed_user_params.append(param)

            # 按位置合并参数，去重
            if position == "before":
                all_params = processed_user_params + managed_params
            elif position == "after":
                all_params = managed_params + processed_user_params
            else:  # replace
                all_params = managed_params
            
            # 去重但保持顺序
            final_params = []
            seen = set()
            for param in all_params:
                if param not in seen:
                    final_params.append(param)
                    seen.add(param)

        return " ".join(final_params)

    def calculate_launch_options(self, current_options, game_config):
        """统一的启动选项计算逻辑
        
        消除 apply_game_config() 和 show_diff() 中的重复代码
        保持与原始实现100%功能一致
        """
        config_type = game_config.get("type", "simple")
        
        if config_type in ["script", "template", "raw"]:
            # 使用新的处理器处理复杂配置
            return self.launch_option_handler.apply_config_by_type(current_options, game_config)
        elif self.launch_option_handler.detect_option_type(current_options) == "script":
            # 用户已经在使用脚本配置，跳过管理
            return current_options
        else:
            # 使用传统的前置/后置参数处理
            user_prefix, user_suffix = self.parse_current_params(current_options)

            # 处理前置参数
            prefix_config = game_config.get("prefix", {})
            final_prefix = self.merge_prefix_params(
                user_prefix,
                prefix_config,
                prefix_config.get("user_handling", {}),
                prefix_config.get("conflicts", {}),
            )

            # 处理后置参数
            suffix_config = game_config.get("suffix", {})
            final_suffix = self.merge_suffix_params(
                user_suffix,
                suffix_config,
                suffix_config.get("user_handling", {}),
                suffix_config.get("conflicts", {}),
            )

            # 构建最终参数
            if final_prefix and final_suffix:
                return f"{' '.join(final_prefix)} {COMMAND_PLACEHOLDER} {final_suffix}"
            elif final_prefix:
                return f"{' '.join(final_prefix)} {COMMAND_PLACEHOLDER}"
            elif final_suffix:
                return f"{COMMAND_PLACEHOLDER} {final_suffix}"
            else:
                return COMMAND_PLACEHOLDER

    def apply_game_config(self, app_id, dry_run=False, verbose=True):
        """应用单个游戏的配置"""
        game_config, config_source = self.get_game_config(app_id, verbose=verbose)
        if not game_config:
            if verbose:
                logger.warning(f"No config found for app {app_id}")
            return False

        # 检查 Steam 是否正在运行
        if verbose and not dry_run and self.is_steam_running():
            logger.warning(
                "Warning: Steam is running. Changes may not take effect until Steam is restarted."
            )
            logger.warning("Consider stopping Steam first with: steam -shutdown")

        success = False
        for user_dir in self.get_steam_user_dirs():
            localconfig_path = user_dir / "config" / "localconfig.vdf"

            if not localconfig_path.exists():
                continue

            # 读取当前配置
            data, vdf_format = self.load_vdf_file(localconfig_path)

            apps = (
                data.get("UserLocalConfigStore", {})
                .get("Software", {})
                .get("Valve", {})
                .get("Steam", {})
                .get("apps", {})
            )
            current_options = apps.get(app_id, {}).get("LaunchOptions", "")

            # 备份原始配置
            if self.custom_config.get("global", {}).get("backup_enabled", True):
                self.backup_config(app_id, current_options)

            # 计算新的启动选项
            new_options = self.calculate_launch_options(current_options, game_config)

            # 显示变更
            if not self.are_configs_equivalent(current_options, new_options):
                if verbose:
                    print(f"\nApp {app_id} ({game_config.get('name', 'Unknown')}):")
                    print(f"  Before: {current_options or '(empty)'}")
                    print(f"  After:  {new_options}")
                else:
                    print(f"🔧 {game_config.get('name', f'App {app_id}')}")
                    print(f"   Before: {current_options or '(empty)'}")
                    print(f"   After:  {new_options}")

                if not dry_run:
                    # 备份原始配置
                    if self.custom_config.get("global", {}).get("backup_enabled", True):
                        self.backup_config(app_id, current_options)
                    
                    # 应用更改
                    if app_id not in apps:
                        apps[app_id] = {}
                    apps[app_id]["LaunchOptions"] = new_options

                    # 保存文件
                    self.save_vdf_file(localconfig_path, data, vdf_format)

                    success = True
            else:
                if verbose:
                    print(f"App {app_id}: No changes needed")

        return success



    def backup_config(self, app_id, current_options):
        """备份当前配置"""
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        backup_file = (
            self.backup_dir
            / f"app_{app_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        )

        with open(backup_file, "w") as f:
            f.write(f"# Backup for Steam App {app_id}\n")
            f.write(f"# Created: {datetime.now()}\n")
            f.write("# Original launch options:\n")
            f.write(current_options or "(empty)")

    def apply_all_configs(self, dry_run=False):
        """应用所有游戏配置"""
        # 合并用户配置和社区配置中的所有游戏
        all_games = set()
        all_games.update(self.custom_config.get("games", {}).keys())
        all_games.update(self.community_config.get("games", {}).keys())

        if not all_games:
            print("No game configurations found")
            return

        print(f"Applying configurations for {len(all_games)} games...")
        if dry_run:
            print("DRY RUN MODE - No changes will be made")

        changed_count = 0
        skipped_count = 0
        
        for app_id in all_games:
            if app_id.startswith("example_"):
                continue  # 跳过示例配置
            
            # 简洁模式应用单个游戏配置
            success = self.apply_game_config(app_id, dry_run, verbose=False)
            if success:
                changed_count += 1
            else:
                skipped_count += 1
        
        # 总结
        print(f"\n📊 Summary:")
        print(f"   ✅ {changed_count} games updated")
        print(f"   ⚪ {skipped_count} games no changes needed")

    def show_diff(self, app_id):
        """显示配置差异对比"""
        game_config, config_source = self.get_game_config(app_id)
        if not game_config:
            print(f"No config found for app {app_id}")
            return False

        print(
            f"Configuration diff for app {app_id} ({game_config.get('name', 'Unknown')}):"
        )
        print("=" * 60)

        for user_dir in self.get_steam_user_dirs():
            localconfig_path = user_dir / "config" / "localconfig.vdf"

            if not localconfig_path.exists():
                continue

            # 读取当前配置
            data, vdf_format = self.load_vdf_file(localconfig_path)

            apps = (
                data.get("UserLocalConfigStore", {})
                .get("Software", {})
                .get("Valve", {})
                .get("Steam", {})
                .get("apps", {})
            )
            current_options = apps.get(app_id, {}).get("LaunchOptions", "")

            # 计算新的启动选项
            new_options = self.calculate_launch_options(current_options, game_config)

            # 检查是否有实质性变化
            if not self.are_configs_equivalent(current_options, new_options):
                # 显示详细差异
                print("\n📋 Current configuration:")
                print(f"   {current_options or '(empty)'}")

                print("\n🎯 Proposed configuration:")
                print(f"   {new_options}")
                print("\n🔄 Changes:")

                # 分析具体变化
                if not current_options:
                    print(f"   + Will add: {new_options}")
                elif new_options == COMMAND_PLACEHOLDER:
                    print("   - Will remove all launch options")
                elif game_config.get("type") in ["script", "template", "raw"]:
                    # 复杂配置类型的简化显示
                    config_type = game_config.get("type", "simple")
                    print(f"   🔧 Configuration type: {config_type}")
                    if game_config.get("description"):
                        print(f"   📝 Description: {game_config['description']}")
                    print(f"   - Current: {current_options or '(empty)'}")
                    print(f"   + Proposed: {new_options}")
                else:
                    # 解析当前和新的参数进行详细对比（简单模式）
                    curr_prefix, curr_suffix = self.parse_current_params(
                        current_options
                    )
                    new_prefix, new_suffix = self.parse_current_params(new_options)

                    if curr_prefix != new_prefix:
                        print("   📦 Environment variables:")
                        if curr_prefix:
                            print(f"      - Current: {' '.join(curr_prefix)}")
                        else:
                            print("      - Current: (none)")
                        if new_prefix:
                            print(f"      + Proposed: {' '.join(new_prefix)}")
                        else:
                            print("      + Proposed: (none)")

                    if curr_suffix != new_suffix:
                        print("   🚀 Launch parameters:")
                        if curr_suffix:
                            print(f"      - Current: {curr_suffix}")
                        else:
                            print("      - Current: (none)")
                        if new_suffix:
                            print(f"      + Proposed: {new_suffix}")
                        else:
                            print("      + Proposed: (none)")
            else:
                print("\n✅ No changes needed - configuration is already up to date")

            print("\n" + "=" * 60)
            return True

        return False

    def validate_config(self):
        """验证配置文件"""
        print("Validating configuration...")

        issues = []

        # 验证用户配置
        custom_games = self.custom_config.get("games", {})
        for app_id, game_config in custom_games.items():
            if not app_id.isdigit() and not app_id.startswith("example_"):
                issues.append(f"Custom config - App ID '{app_id}' should be numeric")

            # 检查必需字段
            if "prefix" not in game_config and "suffix" not in game_config:
                issues.append(
                    f"Custom config - App {app_id}: No prefix or suffix configuration"
                )

        # 验证社区配置（只检查格式，不检查内容）
        community_games = self.community_config.get("games", {})
        print(
            f"Found {len(custom_games)} custom configs and {len(community_games)} community configs"
        )

        if issues:
            print("Configuration issues found:")
            for issue in issues:
                print(f"  - {issue}")
        else:
            print("Configuration is valid!")

    def update_community_db(self):
        """手动更新社区数据库"""
        print("Manually updating community database...")
        self.force_update_community_db()
        print("Update completed!")


def main():
    parser = argparse.ArgumentParser(description="Steam Launch Options Manager")
    parser.add_argument(
        "command",
        choices=[
            "apply",
            "apply-all",
            "dry-run",
            "diff",
            "validate",
            "init",
            "update-db",
        ],
        help="Command to execute",
    )
    parser.add_argument("app_id", nargs="?", help="Steam App ID")
    parser.add_argument(
        "--config",
        default="~/.config/steam-launch-manager",
        help="Configuration file path",
    )
    parser.add_argument(
        "--dry-run", action="store_true", help="Preview changes without applying"
    )

    args = parser.parse_args()

    if args.command == "init":
        # 创建对象时会自动初始化目录和配置文件
        manager = SteamLaunchManager(args.config)
        print("Configuration file created/updated")
        return

    manager = SteamLaunchManager(args.config)

    if args.command == "update-db":
        manager.update_community_db()
        return

    if args.command == "validate":
        manager.validate_config()
        return

    if args.command == "apply-all":
        manager.apply_all_configs(dry_run=args.dry_run)
        return

    if not args.app_id:
        logger.error("App ID is required for this command")
        return

    if args.command == "apply":
        manager.apply_game_config(args.app_id, dry_run=args.dry_run)
    elif args.command == "dry-run":
        manager.apply_game_config(args.app_id, dry_run=True)
    elif args.command == "diff":
        manager.show_diff(args.app_id)


if __name__ == "__main__":
    main()
