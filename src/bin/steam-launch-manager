#!/usr/bin/env python3
"""
Steam Launch Options Manager
æ™ºèƒ½ç®¡ç† Steam æ¸¸æˆå¯åŠ¨å‚æ•°ï¼Œæ”¯æŒå‰ç½®/åç½®å‚æ•°åˆå¹¶å’Œå†²çªå¤„ç†
"""

import os
import sys
import argparse
import yaml
import subprocess
from pathlib import Path
from datetime import datetime

try:
    import vdf
except ImportError:
    print("Error: python-vdf library is required. Install with: pip install vdf")
    sys.exit(1)

class SteamLaunchManager:
    def __init__(self, config_path="~/.config/steam-launch-manager.yaml"):
        self.config_path = Path(config_path).expanduser()
        self.config = self.load_config()
        
        # ä½¿ç”¨é…ç½®æ–‡ä»¶ä¸­çš„steam_dirï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤å€¼
        config_steam_dir = self.config.get('global', {}).get('steam_dir')
        if config_steam_dir:
            self.steam_dir = Path(config_steam_dir).expanduser()
        else:
            self.steam_dir = Path.home() / '.local/share/Steam'
            
        self.backup_dir = Path(self.config.get('global', {}).get('backup_path', '~/.config/steam-backups')).expanduser()
        
    def load_config(self):
        """åŠ è½½é…ç½®æ–‡ä»¶"""
        if not self.config_path.exists():
            self.create_default_config()
        
        with open(self.config_path) as f:
            return yaml.safe_load(f) or {}
    
    def create_default_config(self):
        """åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶"""
        default_config = {
            'global': {
                'backup_enabled': True,
                'backup_path': '~/.config/steam-backups',
                'dry_run': False
            },
            'games': {
                'example_440': {
                    'name': 'Team Fortress 2 (ç¤ºä¾‹)',
                    'prefix': {
                        'params': ['DXVK_HUD=fps'],
                        'user_handling': {'preserve': True, 'position': 'before'},
                        'conflicts': {
                            'replace_keys': ['DXVK_HUD'],
                            'merge_keys': {'LD_LIBRARY_PATH': 'prepend'}
                        }
                    },
                    'suffix': {
                        'params': ['-novid', '-high'],
                        'user_handling': {'preserve': True, 'position': 'before'},
                        'conflicts': {
                            'replace_rules': {'-safe': '', '-windowed': '-fullscreen'}
                        }
                    }
                }
            }
        }
        
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, 'w') as f:
            yaml.dump(default_config, f, default_flow_style=False, indent=2)
        
        print(f"Created default config at: {self.config_path}")
        return default_config
    
    def is_steam_running(self):
        """æ£€æŸ¥ Steam æ˜¯å¦æ­£åœ¨è¿è¡Œ"""
        try:
            result = subprocess.run(['pgrep', '-x', 'steam'], 
                                  capture_output=True, text=True)
            return result.returncode == 0
        except:
            return False
    
    def get_steam_user_dirs(self):
        """è·å–æ‰€æœ‰ Steam ç”¨æˆ·ç›®å½•"""
        userdata_dir = self.steam_dir / 'userdata'
        if not userdata_dir.exists():
            return []
        return [d for d in userdata_dir.iterdir() if d.is_dir() and d.name.isdigit()]
    
    def load_vdf_file(self, file_path):
        """å®‰å…¨åŠ è½½VDFæ–‡ä»¶ï¼Œæ”¯æŒæ–‡æœ¬å’ŒäºŒè¿›åˆ¶æ ¼å¼"""
        try:
            # å…ˆå°è¯•æ–‡æœ¬æ ¼å¼
            with open(file_path, 'r', encoding='utf-8') as f:
                return vdf.load(f), 'text'
        except (UnicodeDecodeError, vdf.VDFError):
            try:
                # å†å°è¯•äºŒè¿›åˆ¶æ ¼å¼
                with open(file_path, 'rb') as f:
                    return vdf.binary_load(f), 'binary'
            except vdf.VDFError as e:
                raise Exception(f"Failed to parse VDF file {file_path}: {e}")
    
    def save_vdf_file(self, file_path, data, format_type):
        """ä¿å­˜VDFæ–‡ä»¶ï¼Œä¿æŒåŸæ ¼å¼"""
        if format_type == 'text':
            with open(file_path, 'w', encoding='utf-8') as f:
                vdf.dump(data, f, pretty=True)
        else:
            with open(file_path, 'wb') as f:
                f.write(vdf.binary_dumps(data))
    
    def parse_current_params(self, current_options):
        """è§£æå½“å‰å¯åŠ¨å‚æ•°ä¸ºå‰ç½®å’Œåç½®éƒ¨åˆ†"""
        if not current_options:
            return [], ""
        
        if '%command%' not in current_options:
            return [], current_options.strip()
        
        parts = current_options.split('%command%', 1)
        prefix_part = parts[0].strip()
        suffix_part = parts[1].strip() if len(parts) > 1 else ""
        
        prefix_params = prefix_part.split() if prefix_part else []
        return prefix_params, suffix_part
    
    def merge_prefix_params(self, user_prefix, config_prefix, user_handling, conflicts):
        """åˆå¹¶å‰ç½®å‚æ•°"""
        managed_params = config_prefix.get('params', [])
        preserve = user_handling.get('preserve', True)
        position = user_handling.get('position', 'before')
        
        if not preserve:
            return managed_params
        
        # å¤„ç†å†²çªè§„åˆ™
        final_user_params = user_prefix.copy()
        replace_keys = conflicts.get('replace_keys', [])
        merge_keys = conflicts.get('merge_keys', {})
        
        # æ„å»ºç¯å¢ƒå˜é‡å­—å…¸ç”¨äºå†²çªå¤„ç†
        user_env = {}
        managed_env = {}
        
        # è§£æç”¨æˆ·çš„ç¯å¢ƒå˜é‡
        user_non_env = []
        for param in final_user_params:
            if '=' in param and not param.startswith('-'):
                key, value = param.split('=', 1)
                user_env[key] = value
            else:
                user_non_env.append(param)
        
        # è§£æç®¡ç†çš„ç¯å¢ƒå˜é‡
        managed_non_env = []
        for param in managed_params:
            if '=' in param and not param.startswith('-'):
                key, value = param.split('=', 1)
                managed_env[key] = value
            else:
                managed_non_env.append(param)
        
        # å¤„ç†ç¯å¢ƒå˜é‡å†²çª
        final_env = user_env.copy()
        
        # æ›¿æ¢è§„åˆ™ï¼šå¼ºåˆ¶ä½¿ç”¨ç®¡ç†çš„å€¼
        for key in replace_keys:
            if key in managed_env:
                final_env[key] = managed_env[key]
        
        # æ·»åŠ ç®¡ç†çš„æ–°ç¯å¢ƒå˜é‡
        for key, value in managed_env.items():
            if key not in final_env:
                final_env[key] = value
        
        # å¤„ç†è·¯å¾„åˆå¹¶
        for key, merge_type in merge_keys.items():
            if key in managed_env and key in user_env:
                if merge_type == 'prepend':
                    final_env[key] = f"{managed_env[key]}:{user_env[key]}"
                elif merge_type == 'append':
                    final_env[key] = f"{user_env[key]}:{managed_env[key]}"
        
        # é‡å»ºå‚æ•°åˆ—è¡¨
        env_params = [f"{k}={v}" for k, v in final_env.items()]
        
        if position == 'before':
            return env_params + user_non_env + managed_non_env
        elif position == 'after':
            return managed_non_env + env_params + user_non_env
        else:  # replace
            return env_params + managed_non_env
    
    def merge_suffix_params(self, user_suffix, config_suffix, user_handling, conflicts):
        """åˆå¹¶åç½®å‚æ•°"""
        managed_params = config_suffix.get('params', [])
        preserve = user_handling.get('preserve', True)
        position = user_handling.get('position', 'before')
        
        user_params = user_suffix.split() if user_suffix else []
        
        if not preserve:
            final_params = managed_params
        else:
            # å¤„ç†æ›¿æ¢è§„åˆ™
            replace_rules = conflicts.get('replace_rules', {})
            processed_user_params = []
            
            for param in user_params:
                if param in replace_rules:
                    replacement = replace_rules[param]
                    if replacement:  # å¦‚æœæ›¿æ¢å€¼ä¸ä¸ºç©º
                        processed_user_params.append(replacement)
                    # å¦‚æœæ›¿æ¢å€¼ä¸ºç©ºï¼Œåˆ™è·³è¿‡ï¼ˆåˆ é™¤è¯¥å‚æ•°ï¼‰
                else:
                    processed_user_params.append(param)
            
            # æŒ‰ä½ç½®åˆå¹¶å‚æ•°
            if position == 'before':
                final_params = processed_user_params + managed_params
            elif position == 'after':
                final_params = managed_params + processed_user_params
            else:  # replace
                final_params = managed_params
        
        return ' '.join(final_params)
    
    def apply_game_config(self, app_id, dry_run=False):
        """åº”ç”¨å•ä¸ªæ¸¸æˆçš„é…ç½®"""
        game_config = self.config.get('games', {}).get(app_id)
        if not game_config:
            print(f"No config found for app {app_id}")
            return False
        
        # æ£€æŸ¥ Steam æ˜¯å¦æ­£åœ¨è¿è¡Œ
        if not dry_run and self.is_steam_running():
            print("Warning: Steam is running. Changes may not take effect until Steam is restarted.")
            print("Consider stopping Steam first with: steam -shutdown")
        
        success = False
        for user_dir in self.get_steam_user_dirs():
            localconfig_path = user_dir / 'config' / 'localconfig.vdf'
            
            if not localconfig_path.exists():
                continue
            
            # è¯»å–å½“å‰é…ç½®
            data, vdf_format = self.load_vdf_file(localconfig_path)
            
            apps = data.get('UserLocalConfigStore', {}).get('Software', {}).get('Valve', {}).get('Steam', {}).get('apps', {})
            current_options = apps.get(app_id, {}).get('LaunchOptions', '')
            
            # å¤‡ä»½åŸå§‹é…ç½®
            if self.config.get('global', {}).get('backup_enabled', True):
                self.backup_config(app_id, current_options)
            
            # è§£æå’Œåˆå¹¶å‚æ•°
            user_prefix, user_suffix = self.parse_current_params(current_options)
            
            # å¤„ç†å‰ç½®å‚æ•°
            prefix_config = game_config.get('prefix', {})
            final_prefix = self.merge_prefix_params(
                user_prefix,
                prefix_config,
                prefix_config.get('user_handling', {}),
                prefix_config.get('conflicts', {})
            )
            
            # å¤„ç†åç½®å‚æ•°
            suffix_config = game_config.get('suffix', {})
            final_suffix = self.merge_suffix_params(
                user_suffix,
                suffix_config,
                suffix_config.get('user_handling', {}),
                suffix_config.get('conflicts', {})
            )
            
            # æ„å»ºæœ€ç»ˆå‚æ•°
            if final_prefix and final_suffix:
                new_options = f"{' '.join(final_prefix)} %command% {final_suffix}"
            elif final_prefix:
                new_options = f"{' '.join(final_prefix)} %command%"
            elif final_suffix:
                new_options = f"%command% {final_suffix}"
            else:
                new_options = "%command%"
            
            # æ˜¾ç¤ºå˜æ›´
            if current_options != new_options:
                print(f"\nApp {app_id} ({game_config.get('name', 'Unknown')}):")
                print(f"  Before: {current_options or '(empty)'}")
                print(f"  After:  {new_options}")
                
                if not dry_run:
                    # åº”ç”¨æ›´æ”¹
                    if app_id not in apps:
                        apps[app_id] = {}
                    apps[app_id]['LaunchOptions'] = new_options
                    
                    # ä¿å­˜æ–‡ä»¶
                    self.save_vdf_file(localconfig_path, data, vdf_format)
                    
                    success = True
            else:
                print(f"App {app_id}: No changes needed")
        
        return success
    
    def backup_config(self, app_id, current_options):
        """å¤‡ä»½å½“å‰é…ç½®"""
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        backup_file = self.backup_dir / f"app_{app_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        
        with open(backup_file, 'w') as f:
            f.write(f"# Backup for Steam App {app_id}\n")
            f.write(f"# Created: {datetime.now()}\n")
            f.write(f"# Original launch options:\n")
            f.write(current_options or "(empty)")
    
    def apply_all_configs(self, dry_run=False):
        """åº”ç”¨æ‰€æœ‰æ¸¸æˆé…ç½®"""
        games = self.config.get('games', {})
        if not games:
            print("No game configurations found")
            return
        
        print(f"Applying configurations for {len(games)} games...")
        if dry_run:
            print("DRY RUN MODE - No changes will be made")
        
        for app_id in games:
            if app_id.startswith('example_'):
                continue  # è·³è¿‡ç¤ºä¾‹é…ç½®
            self.apply_game_config(app_id, dry_run)
    
    def show_diff(self, app_id):
        """æ˜¾ç¤ºé…ç½®å·®å¼‚å¯¹æ¯”"""
        game_config = self.config.get('games', {}).get(app_id)
        if not game_config:
            print(f"No config found for app {app_id}")
            return False
        
        print(f"Configuration diff for app {app_id} ({game_config.get('name', 'Unknown')}):")
        print("=" * 60)
        
        for user_dir in self.get_steam_user_dirs():
            localconfig_path = user_dir / 'config' / 'localconfig.vdf'
            
            if not localconfig_path.exists():
                continue
            
            # è¯»å–å½“å‰é…ç½®
            data, vdf_format = self.load_vdf_file(localconfig_path)
            
            apps = data.get('UserLocalConfigStore', {}).get('Software', {}).get('Valve', {}).get('Steam', {}).get('apps', {})
            current_options = apps.get(app_id, {}).get('LaunchOptions', '')
            
            # è®¡ç®—æ–°é…ç½®
            user_prefix, user_suffix = self.parse_current_params(current_options)
            
            # å¤„ç†å‰ç½®å‚æ•°
            prefix_config = game_config.get('prefix', {})
            final_prefix = self.merge_prefix_params(
                user_prefix,
                prefix_config,
                prefix_config.get('user_handling', {}),
                prefix_config.get('conflicts', {})
            )
            
            # å¤„ç†åç½®å‚æ•°
            suffix_config = game_config.get('suffix', {})
            final_suffix = self.merge_suffix_params(
                user_suffix,
                suffix_config,
                suffix_config.get('user_handling', {}),
                suffix_config.get('conflicts', {})
            )
            
            # æ„å»ºæœ€ç»ˆå‚æ•°
            if final_prefix and final_suffix:
                new_options = f"{' '.join(final_prefix)} %command% {final_suffix}"
            elif final_prefix:
                new_options = f"{' '.join(final_prefix)} %command%"
            elif final_suffix:
                new_options = f"%command% {final_suffix}"
            else:
                new_options = "%command%"
            
            # æ˜¾ç¤ºè¯¦ç»†å·®å¼‚
            print(f"\nğŸ“‹ Current configuration:")
            print(f"   {current_options or '(empty)'}")
            
            print(f"\nğŸ¯ Proposed configuration:")
            print(f"   {new_options}")
            
            if current_options != new_options:
                print(f"\nğŸ”„ Changes:")
                
                # åˆ†æå…·ä½“å˜åŒ–
                if not current_options:
                    print(f"   + Will add: {new_options}")
                elif new_options == "%command%":
                    print(f"   - Will remove all launch options")
                else:
                    # è§£æå½“å‰å’Œæ–°çš„å‚æ•°è¿›è¡Œè¯¦ç»†å¯¹æ¯”
                    curr_prefix, curr_suffix = self.parse_current_params(current_options)
                    new_prefix, new_suffix = self.parse_current_params(new_options)
                    
                    if curr_prefix != new_prefix:
                        print(f"   ğŸ“¦ Environment variables:")
                        if curr_prefix:
                            print(f"      - Current: {' '.join(curr_prefix)}")
                        else:
                            print(f"      - Current: (none)")
                        if new_prefix:
                            print(f"      + Proposed: {' '.join(new_prefix)}")
                        else:
                            print(f"      + Proposed: (none)")
                    
                    if curr_suffix != new_suffix:
                        print(f"   ğŸš€ Launch parameters:")
                        if curr_suffix:
                            print(f"      - Current: {curr_suffix}")
                        else:
                            print(f"      - Current: (none)")
                        if new_suffix:
                            print(f"      + Proposed: {new_suffix}")
                        else:
                            print(f"      + Proposed: (none)")
            else:
                print(f"\nâœ… No changes needed - configuration is already up to date")
            
            print("\n" + "=" * 60)
            return True
        
        return False
    
    def validate_config(self):
        """éªŒè¯é…ç½®æ–‡ä»¶"""
        print("Validating configuration...")
        
        games = self.config.get('games', {})
        issues = []
        
        for app_id, game_config in games.items():
            if not app_id.isdigit() and not app_id.startswith('example_'):
                issues.append(f"App ID '{app_id}' should be numeric")
            
            # æ£€æŸ¥å¿…éœ€å­—æ®µ
            if 'prefix' not in game_config and 'suffix' not in game_config:
                issues.append(f"App {app_id}: No prefix or suffix configuration")
        
        if issues:
            print("Configuration issues found:")
            for issue in issues:
                print(f"  - {issue}")
        else:
            print("Configuration is valid!")

def main():
    parser = argparse.ArgumentParser(description="Steam Launch Options Manager")
    parser.add_argument('command', choices=['apply', 'apply-all', 'dry-run', 'diff', 'validate', 'init'],
                       help='Command to execute')
    parser.add_argument('app_id', nargs='?', help='Steam App ID')
    parser.add_argument('--config', default='~/.config/steam-launch-manager.yaml',
                       help='Configuration file path')
    parser.add_argument('--dry-run', action='store_true', help='Preview changes without applying')
    
    args = parser.parse_args()
    
    manager = SteamLaunchManager(args.config)
    
    if args.command == 'init':
        print("Configuration file created/updated")
        return
    
    if args.command == 'validate':
        manager.validate_config()
        return
    
    if args.command == 'apply-all':
        manager.apply_all_configs(dry_run=args.dry_run)
        return
    
    if not args.app_id:
        print("App ID is required for this command")
        return
    
    if args.command == 'apply':
        manager.apply_game_config(args.app_id, dry_run=args.dry_run)
    elif args.command == 'dry-run':
        manager.apply_game_config(args.app_id, dry_run=True)
    elif args.command == 'diff':
        manager.show_diff(args.app_id)

if __name__ == '__main__':
    main() 