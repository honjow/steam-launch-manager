#!/usr/bin/env python3
"""
Steam Launch Options Manager
æ™ºèƒ½ç®¡ç† Steam æ¸¸æˆå¯åŠ¨å‚æ•°ï¼Œæ”¯æŒå‰ç½®/åç½®å‚æ•°åˆå¹¶å’Œå†²çªå¤„ç†
"""

import argparse
import logging
import subprocess
import sys
from datetime import datetime
from pathlib import Path
import re

import yaml

try:
    import vdf
except ImportError:
    print("Error: python-vdf library is required. Install with: pip install vdf")
    sys.exit(1)

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger('steam-launch-manager')

# =============================================================================
# é…ç½®å‚æ•° - Configuration Parameters
# =============================================================================

APP_NAME = "steam-launch-manager"
INNER_DB_PATH = f"/usr/share/{APP_NAME}/data/games-db.yaml"
INNER_VERSION_PATH = f"/usr/share/{APP_NAME}/VERSION"

# Steam å¯åŠ¨å‚æ•°å ä½ç¬¦
COMMAND_PLACEHOLDER = "%command%"

# ç¤¾åŒºæ•°æ®åº“æ›´æ–°é…ç½®
COMMUNITY_DB_URLS = [
    "https://gitee.com/honjow/steam-launch-manager/raw/master/src/data/games-db.yaml",  # é•œåƒåœ°å€
    "https://raw.githubusercontent.com/honjow/steam-launch-manager/refs/heads/master/src/data/games-db.yaml",
    "https://cdn.jsdelivr.net/gh/honjow/steam-launch-manager@master/src/data/games-db.yaml",  # CDNé•œåƒ
]
VERSION_CHECK_URLS = [
    "https://gitee.com/honjow/steam-launch-manager/raw/master/src/data/VERSION",
    "https://raw.githubusercontent.com/honjow/steam-launch-manager/refs/heads/master/src/data/VERSION",
    "https://cdn.jsdelivr.net/gh/honjow/steam-launch-manager@master/src/data/VERSION",
]
UPDATE_CHECK_INTERVAL_HOURS = 1  # æ£€æŸ¥æ›´æ–°é—´éš”ï¼ˆå°æ—¶ï¼‰
NETWORK_TIMEOUT_SECONDS = 10  # ç½‘ç»œè¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
USER_AGENT = "steam-launch-manager/1.0"  # ç”¨æˆ·ä»£ç†å­—ç¬¦ä¸²

# ç½‘ç»œä¼˜åŒ–é…ç½®
NETWORK_QUICK_TIMEOUT = 2      # å¿«é€Ÿç½‘ç»œæ£€æµ‹è¶…æ—¶
NETWORK_VERSION_TIMEOUT = 1    # ç‰ˆæœ¬æ£€æŸ¥è¶…æ—¶  
NETWORK_DOWNLOAD_TIMEOUT = 3   # å¿«é€Ÿä¸‹è½½è¶…æ—¶
NETWORK_RETRY_TIMEOUT = 5      # é‡è¯•æ—¶çš„è¶…æ—¶

# é‡è¯•é…ç½®
RETRY_ATTEMPTS = 3             # æœ€å¤§é‡è¯•æ¬¡æ•°
RETRY_DELAY_BASE = 1           # åŸºç¡€å»¶è¿Ÿï¼ˆç§’ï¼‰
RETRY_DELAY_MAX = 8            # æœ€å¤§å»¶è¿Ÿï¼ˆç§’ï¼‰

# DNSæœåŠ¡å™¨ç”¨äºç½‘ç»œæ£€æµ‹
NETWORK_TEST_HOSTS = [
    ('8.8.8.8', 53),           # Google DNS
    ('1.1.1.1', 53),           # Cloudflare DNS
    ('114.114.114.114', 53)    # å›½å†…DNS
]

# é»˜è®¤é…ç½®è·¯å¾„
DEFAULT_CONFIG_PATH = "~/.config/steam-launch-manager"
DEFAULT_STEAM_PATH = "~/.local/share/Steam"
DEFAULT_BACKUP_PATH = "~/.config/steam-backups"

# =============================================================================
# å¯åŠ¨é€‰é¡¹ç±»å‹å®šä¹‰ - Launch Option Types
# =============================================================================

LAUNCH_OPTION_TYPES = {
    "simple": "ç®€å•å‰ç½®/åç½®å‚æ•°",
    "script": "å¤æ‚Shellè„šæœ¬",
    "template": "æ¨¡æ¿æ›¿æ¢",
    "raw": "åŸå§‹æ›¿æ¢ï¼ˆä¸è§£æï¼‰"
}

class LaunchOptionHandler:
    """å¯åŠ¨é€‰é¡¹å¤„ç†å™¨ - æ”¯æŒä¸åŒç±»å‹çš„å¯åŠ¨é€‰é¡¹"""
    
    def __init__(self):
        self.command_placeholder_pattern = re.compile(r'%command%', re.IGNORECASE)
    
    def detect_option_type(self, launch_options):
        """æ£€æµ‹å¯åŠ¨é€‰é¡¹çš„ç±»å‹"""
        if not launch_options:
            return "simple"
            
        # æ£€æµ‹å¤æ‚è„šæœ¬æ¨¡å¼
        script_indicators = [
            'eval $(',
            'ln -s',
            'IFS=:',
            '|', 
            '&&',
            '||',
            'for ',
            'if [',
            'sed "s/'
        ]
        
        if any(indicator in launch_options for indicator in script_indicators):
            return "script"
            
        # æ£€æµ‹æ¨¡æ¿æ›¿æ¢
        if '${' in launch_options or '$(' in launch_options:
            return "template"
            
        # é»˜è®¤ä¸ºç®€å•æ¨¡å¼
        return "simple"
    
    def apply_config_by_type(self, current_options, game_config):
        """æ ¹æ®é…ç½®ç±»å‹åº”ç”¨ä¸åŒçš„å¤„ç†é€»è¾‘"""
        config_type = game_config.get("type", "simple")
        
        if config_type == "raw":
            return self._apply_raw_config(current_options, game_config)
        elif config_type == "script":
            return self._apply_script_config(current_options, game_config)
        elif config_type == "template":
            return self._apply_template_config(current_options, game_config)
        else:
            return self._apply_simple_config(current_options, game_config)
    
    def _apply_raw_config(self, current_options, game_config):
        """åŸå§‹æ›¿æ¢æ¨¡å¼ - ç›´æ¥ä½¿ç”¨é…ç½®ä¸­çš„å¯åŠ¨é€‰é¡¹"""
        raw_options = game_config.get("raw_options", "")
        return raw_options
    
    def _apply_script_config(self, current_options, game_config):
        """è„šæœ¬æ¨¡å¼ - ä¿æŒå¤æ‚è„šæœ¬çš„å®Œæ•´æ€§"""
        script_template = game_config.get("script_template", "")
        
        # å¯¹äºè„šæœ¬æ¨¡å¼ï¼Œæˆ‘ä»¬é€šå¸¸ä¸è¿›è¡Œå¤æ‚çš„åˆå¹¶
        # è€Œæ˜¯æä¾›æ•´ä¸ªè„šæœ¬ä½œä¸ºå¯åŠ¨é€‰é¡¹
        if script_template:
            return script_template
        
        # å¦‚æœæ²¡æœ‰æ¨¡æ¿ï¼Œå›é€€åˆ°ç®€å•æ¨¡å¼
        return self._apply_simple_config(current_options, game_config)
    
    def _apply_template_config(self, current_options, game_config):
        """æ¨¡æ¿æ¨¡å¼ - æ”¯æŒå˜é‡æ›¿æ¢"""
        template = game_config.get("template", "")
        variables = game_config.get("variables", {})
        
        # æ›¿æ¢æ¨¡æ¿ä¸­çš„å˜é‡
        result = template
        for var_name, var_value in variables.items():
            result = result.replace(f"${{{var_name}}}", str(var_value))
        
        return result
    
    def _apply_simple_config(self, current_options, game_config):
        """ç®€å•æ¨¡å¼ - ä½¿ç”¨ç°æœ‰çš„å‰ç½®/åç½®å‚æ•°é€»è¾‘"""
        # è¿™ä¸ªæ–¹æ³•åœ¨ä¸»ç±»ä¸­ä¼šè¢«è¦†ç›–
        # è¿™é‡Œåªæ˜¯å ä½ç¬¦ï¼Œå®é™…å¤„ç†åœ¨ SteamLaunchManager ä¸­
        return current_options

class SteamLaunchManager:
    def __init__(self, config_path=None):
        if config_path is None:
            config_path = DEFAULT_CONFIG_PATH

        self.config_dir = Path(config_path).expanduser()
        self.custom_config_path = self.config_dir / "custom" / "games.yaml"
        self.community_config_path = self.config_dir / "community" / "games.yaml"
        self.community_version_path = self.config_dir / "community" / "version.txt"

        # åˆå§‹åŒ–å¯åŠ¨é€‰é¡¹å¤„ç†å™¨
        self.launch_option_handler = LaunchOptionHandler()

        # ç¡®ä¿ç›®å½•å­˜åœ¨
        self.config_dir.mkdir(parents=True, exist_ok=True)
        (self.config_dir / "custom").mkdir(exist_ok=True)
        (self.config_dir / "community").mkdir(exist_ok=True)

        # åŠ è½½é…ç½®
        self.custom_config = self.load_custom_config()
        self.community_config = self.load_community_config()

        # æ£€æŸ¥å¹¶åº”ç”¨å†…ç½®ç‰ˆæœ¬æ›´æ–°
        self.check_inner_version_update()

        # ç½‘ç»œæ£€æŸ¥ä¼˜åŒ–ï¼šä¸¥æ ¼æ§åˆ¶æ—¶é—´
        import time
        start_time = time.time()
        try:
            # æ£€æŸ¥ç¤¾åŒºé…ç½®æ›´æ–°ï¼ˆä¼˜åŒ–ç‰ˆæœ¬ï¼‰
            self.check_community_updates()
        except Exception as e:
            logger.debug(f"Network check failed: {e}")
        
        # è®°å½•åˆå§‹åŒ–æ—¶é—´
        elapsed = time.time() - start_time
        if elapsed > 3.0:  # å¦‚æœè¶…è¿‡3ç§’è®°å½•è­¦å‘Š
            logger.warning(f"Network check took {elapsed:.1f}s, consider disabling auto-update")

        # ä½¿ç”¨é…ç½®æ–‡ä»¶ä¸­çš„steam_dirï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤å€¼
        config_steam_dir = self.custom_config.get("global", {}).get("steam_dir")
        if config_steam_dir:
            self.steam_dir = Path(config_steam_dir).expanduser()
        else:
            self.steam_dir = Path(DEFAULT_STEAM_PATH).expanduser()

        self.backup_dir = Path(
            self.custom_config.get("global", {}).get("backup_path", DEFAULT_BACKUP_PATH)
        ).expanduser()

    def load_custom_config(self):
        """åŠ è½½ç”¨æˆ·è‡ªå®šä¹‰é…ç½®"""
        if not self.custom_config_path.exists():
            self.create_default_custom_config()

        with open(self.custom_config_path) as f:
            return yaml.safe_load(f) or {}

    def load_community_config(self):
        """åŠ è½½ç¤¾åŒºé¢„è®¾é…ç½®"""
        if not self.community_config_path.exists():
            return {"games": {}}

        with open(self.community_config_path) as f:
            return yaml.safe_load(f) or {"games": {}}

    def create_default_custom_config(self):
        """åˆ›å»ºé»˜è®¤çš„ç”¨æˆ·è‡ªå®šä¹‰é…ç½®æ–‡ä»¶"""
        default_config = {
            "global": {
                "backup_enabled": True,
                "backup_path": DEFAULT_BACKUP_PATH,
                "dry_run": False,
                "auto_update_community_db": True,
                
                # ç½‘ç»œé…ç½®ï¼ˆå¯é€‰ï¼‰
                "network": {
                    "quick_timeout_seconds": 2,
                    "retry_attempts": 3,
                    "background_update": True
                }
            },
            "games": {
                # ç”¨æˆ·å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è‡ªå·±çš„æ¸¸æˆé…ç½®
                # ç¤ºä¾‹ï¼ˆå¯ä»¥åˆ é™¤ï¼‰:
                # "730": {
                #     "name": "Counter-Strike 2 - Custom",
                #     "prefix": {
                #         "params": ["RADV_PERFTEST=aco"]
                #     }
                # }
            },
        }

        self.custom_config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.custom_config_path, "w") as f:
            yaml.dump(default_config, f, default_flow_style=False, indent=2)

        logger.info(f"Created custom config at: {self.custom_config_path}")
        return default_config

    def get_game_config(self, app_id, verbose=True):
        """è·å–æ¸¸æˆé…ç½®ï¼šç”¨æˆ·é…ç½®ä¼˜å…ˆäºç¤¾åŒºé…ç½®"""
        # 1. æ£€æŸ¥ç”¨æˆ·è‡ªå®šä¹‰é…ç½®
        custom_games = self.custom_config.get("games", {})
        if app_id in custom_games:
            if verbose:
                logger.info(f"Using custom config for {app_id}")
            return custom_games[app_id], "custom"

        # 2. ä½¿ç”¨ç¤¾åŒºé¢„è®¾é…ç½®
        community_games = self.community_config.get("games", {})
        if app_id in community_games:
            if verbose:
                logger.info(f"Using community config for {app_id}")
            return community_games[app_id], "community"

        # 3. æ²¡æœ‰é…ç½®
        return None, None

    def check_inner_version_update(self):
        """æ£€æŸ¥å†…ç½®ç‰ˆæœ¬å¹¶åœ¨ç‰ˆæœ¬æ›´é«˜æ—¶è¦†ç›–æœ¬åœ°æ•°æ®åº“"""
        try:
            inner_version = self._get_inner_version()
            if not inner_version:
                return
            
            local_version = self._get_local_version()
            
            # æ¯”è¾ƒç‰ˆæœ¬
            if self._is_version_higher(inner_version, local_version):
                logger.info(f"å‘ç°æ›´é«˜ç‰ˆæœ¬çš„å†…ç½®æ•°æ®åº“: {inner_version} (å½“å‰: {local_version or 'æ— '})")
                
                # å¤åˆ¶å†…ç½®æ•°æ®åº“åˆ°æœ¬åœ°
                if self._copy_inner_database():
                    logger.info("å†…ç½®æ•°æ®åº“å·²æˆåŠŸè¦†ç›–æœ¬åœ°é…ç½®")
                    
                    # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
                    self._update_version_info_for_inner(inner_version)
                    
                    # é‡æ–°åŠ è½½ç¤¾åŒºé…ç½®
                    self.community_config = self.load_community_config()
                else:
                    logger.error("å¤åˆ¶å†…ç½®æ•°æ®åº“å¤±è´¥")
            elif inner_version == local_version:
                logger.debug(f"å†…ç½®æ•°æ®åº“ç‰ˆæœ¬å·²æ˜¯æœ€æ–°: {inner_version}")
        
        except Exception as e:
            logger.error(f"æ£€æŸ¥å†…ç½®ç‰ˆæœ¬æ—¶å‡ºé”™: {e}")

    def _get_inner_version(self):
        """è·å–å†…ç½®ç‰ˆæœ¬å·"""
        try:
            inner_version_path = Path(INNER_VERSION_PATH)
            if inner_version_path.exists():
                with open(inner_version_path, 'r', encoding='utf-8') as f:
                    return f.read().strip()
        except Exception as e:
            logger.error(f"è¯»å–å†…ç½®ç‰ˆæœ¬æ–‡ä»¶å¤±è´¥: {e}")
        return None

    def _is_version_higher(self, version1, version2):
        """æ¯”è¾ƒç‰ˆæœ¬å·ï¼Œè¿”å› version1 æ˜¯å¦é«˜äº version2"""
        if not version2:  # æœ¬åœ°ç‰ˆæœ¬ä¸å­˜åœ¨ï¼Œå†…ç½®ç‰ˆæœ¬æ›´é«˜
            return True
        if not version1:  # å†…ç½®ç‰ˆæœ¬ä¸å­˜åœ¨
            return False
        
        try:
            # å°†ç‰ˆæœ¬å·è½¬æ¢ä¸ºå¯æ¯”è¾ƒçš„å…ƒç»„
            def version_tuple(v):
                return tuple(map(int, v.split('.')))
            
            return version_tuple(version1) > version_tuple(version2)
        except ValueError:
            # å¦‚æœç‰ˆæœ¬å·æ ¼å¼ä¸æ­£ç¡®ï¼Œä½¿ç”¨å­—ç¬¦ä¸²æ¯”è¾ƒ
            return version1 > version2

    def _copy_inner_database(self):
        """å¤åˆ¶å†…ç½®æ•°æ®åº“åˆ°æœ¬åœ°ç¤¾åŒºé…ç½®"""
        try:
            inner_db_path = Path(INNER_DB_PATH)
            if not inner_db_path.exists():
                logger.error(f"å†…ç½®æ•°æ®åº“æ–‡ä»¶ä¸å­˜åœ¨: {inner_db_path}")
                return False
            
            # ç¡®ä¿ç›®å½•å­˜åœ¨
            self.community_config_path.parent.mkdir(parents=True, exist_ok=True)
            
            # å¤åˆ¶æ–‡ä»¶
            import shutil
            shutil.copy2(inner_db_path, self.community_config_path)
            
            return True
        except Exception as e:
            logger.error(f"å¤åˆ¶å†…ç½®æ•°æ®åº“å¤±è´¥: {e}")
            return False

    def _update_version_info_for_inner(self, inner_version):
        """ä¸ºå†…ç½®æ•°æ®åº“æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯"""
        try:
            with open(self.community_version_path, "w", encoding="utf-8") as f:
                f.write(f"Updated: {datetime.now().isoformat()}\n")
                f.write(f"Source: inner_database\n")
                f.write(f"Version: {inner_version}\n")
        except Exception as e:
            logger.error(f"æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯å¤±è´¥: {e}")

    def _quick_network_check(self, timeout=2):
        """å¿«é€Ÿç½‘ç»œè¿é€šæ€§æ£€æµ‹"""
        import socket
        
        for host, port in NETWORK_TEST_HOSTS:
            try:
                sock = socket.create_connection((host, port), timeout=timeout/len(NETWORK_TEST_HOSTS))
                sock.close()
                return True
            except:
                continue
        return False

    def check_community_updates(self):
        """æ£€æŸ¥å¹¶æ›´æ–°ç¤¾åŒºé…ç½®æ•°æ®åº“ - ä¼˜åŒ–ç‰ˆæœ¬"""
        auto_update = self.custom_config.get("global", {}).get(
            "auto_update_community_db", True
        )
        if not auto_update:
            return

        # å¿«é€Ÿæ£€æŸ¥é˜¶æ®µï¼ˆåŒæ­¥ï¼Œ5ç§’å†…å®Œæˆï¼‰
        quick_result = self._quick_update_check()
        
        if quick_result == "no_network":
            logger.debug("Network unavailable, using local cache")
            return
        elif quick_result == "up_to_date":
            logger.debug("Database is up to date")
            return
        elif quick_result == "need_download":
            # å¯åŠ¨å¼‚æ­¥åå°ä¸‹è½½
            self._start_background_download()

    def _quick_update_check(self):
        """å¿«é€Ÿæ›´æ–°æ£€æŸ¥ - 5ç§’å†…å®Œæˆ"""
        # 1. ç½‘ç»œè¿é€šæ€§æ£€æµ‹ (2ç§’)
        if not self._quick_network_check(timeout=NETWORK_QUICK_TIMEOUT):
            return "no_network"
        
        # 2. å¿«é€Ÿç‰ˆæœ¬æ£€æŸ¥ (1ç§’)  
        try:
            remote_version = self._get_remote_version_quick()
            local_version = self._get_local_version()
            
            if remote_version and local_version and remote_version == local_version:
                self._update_check_timestamp()
                return "up_to_date"
            else:
                return "need_download"
        except Exception as e:
            logger.debug(f"Quick version check failed: {e}")
            return "no_network"

    def _should_update_database(self):
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥æ›´æ–°æ•°æ®åº“"""
        # å¦‚æœæ˜¯å¼ºåˆ¶æ›´æ–°ï¼Œè·³è¿‡æ—¶é—´æ£€æŸ¥ä½†ä»è¿›è¡Œç‰ˆæœ¬æ¯”è¾ƒ
        if hasattr(self, "_force_update") and self._force_update:
            return True

        # å¦‚æœç¤¾åŒºé…ç½®ä¸å­˜åœ¨ï¼Œéœ€è¦æ›´æ–°
        if not self.community_config_path.exists():
            return True

        # æ£€æŸ¥ä¸Šæ¬¡æ›´æ–°æ—¶é—´
        if not self.community_version_path.exists():
            return True

        try:
            import time

            # è·å–æ–‡ä»¶æœ€åä¿®æ”¹æ—¶é—´
            last_modified = self.community_version_path.stat().st_mtime
            current_time = time.time()

            # å¦‚æœè¶…è¿‡æŒ‡å®šå°æ—¶æ•°æ²¡æ›´æ–°ï¼Œåˆ™éœ€è¦æ›´æ–°
            if current_time - last_modified > UPDATE_CHECK_INTERVAL_HOURS * 3600:
                return True

        except Exception:
            return True

        return False

    def _get_remote_version_quick(self):
        """å¿«é€Ÿè·å–è¿œç¨‹ç‰ˆæœ¬ä¿¡æ¯"""
        import urllib.error
        import urllib.request

        for url in VERSION_CHECK_URLS:
            try:
                request = urllib.request.Request(url)
                request.add_header("User-Agent", USER_AGENT)

                with urllib.request.urlopen(
                    request, timeout=NETWORK_VERSION_TIMEOUT
                ) as response:
                    version = response.read().decode("utf-8").strip()
                    if version:
                        return version
            except (urllib.error.URLError, Exception):
                continue
        return None

    def _get_remote_version(self):
        """è·å–è¿œç¨‹ç‰ˆæœ¬ä¿¡æ¯"""
        import urllib.error
        import urllib.request

        for url in VERSION_CHECK_URLS:
            try:
                request = urllib.request.Request(url)
                request.add_header("User-Agent", USER_AGENT)

                with urllib.request.urlopen(
                    request, timeout=NETWORK_TIMEOUT_SECONDS
                ) as response:
                    version = response.read().decode("utf-8").strip()
                    if version:
                        return version
            except (urllib.error.URLError, Exception):
                continue
        return None

    def _get_local_version(self):
        """è·å–æœ¬åœ°ç‰ˆæœ¬ä¿¡æ¯"""
        try:
            if self.community_version_path.exists():
                with open(self.community_version_path, "r") as f:
                    lines = f.readlines()
                    for line in lines:
                        if line.startswith("Version: "):
                            return line.split("Version: ", 1)[1].strip()
        except Exception:
            pass
        return None

    def _start_background_download(self):
        """å¯åŠ¨åå°ä¸‹è½½çº¿ç¨‹"""
        import threading
        
        def background_worker():
            # ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œç¡®ä¿ä¸»ç¨‹åºå·²ç»å¯åŠ¨å®Œæˆ
            import time
            time.sleep(30)  # 30ç§’åå¼€å§‹åå°æ›´æ–°
            
            logger.info("Starting background database update...")
            success = self._download_with_retry()
            if success:
                logger.info("Background database update completed")
                # é‡æ–°åŠ è½½é…ç½®ï¼ˆä¸ºä¸‹æ¬¡ä½¿ç”¨å‡†å¤‡ï¼‰
                self.community_config = self.load_community_config()
            else:
                logger.debug("Background database update failed")
        
        # åˆ›å»ºå®ˆæŠ¤çº¿ç¨‹
        thread = threading.Thread(target=background_worker, daemon=True)
        thread.start()
        logger.debug("Background update scheduled")

    def _download_with_retry(self):
        """å¸¦é‡è¯•æœºåˆ¶çš„ä¸‹è½½"""
        import time
        
        for attempt in range(RETRY_ATTEMPTS):
            # æŒ‡æ•°é€€é¿å»¶è¿Ÿ
            if attempt > 0:
                delay = min(RETRY_DELAY_BASE * (2 ** (attempt - 1)), RETRY_DELAY_MAX)
                logger.debug(f"Retry attempt {attempt}, waiting {delay}s...")
                time.sleep(delay)
            
            # æ¯æ¬¡é‡è¯•å‰æ£€æŸ¥ç½‘ç»œ
            if not self._quick_network_check(timeout=1):
                logger.debug(f"Network unavailable on attempt {attempt + 1}")
                continue
                
            # å°è¯•ä¸‹è½½
            timeout = NETWORK_RETRY_TIMEOUT if attempt > 0 else NETWORK_DOWNLOAD_TIMEOUT
            success, db_url, content = self._download_database_with_timeout(timeout)
            
            if success and content:
                try:
                    yaml.safe_load(content)
                    with open(self.community_config_path, "w", encoding="utf-8") as f:
                        f.write(content)
                    self._update_version_info(db_url)
                    return True
                except Exception as e:
                    logger.error(f"Failed to save downloaded content: {e}")
                    continue
        
        return False

    def _download_database_with_timeout(self, timeout):
        """å¸¦è¶…æ—¶æ§åˆ¶çš„æ•°æ®åº“ä¸‹è½½"""
        import urllib.error
        import urllib.request
        
        for url in COMMUNITY_DB_URLS:
            try:
                logger.debug(f"Downloading from: {url} (timeout: {timeout}s)")
                request = urllib.request.Request(url)
                request.add_header("User-Agent", USER_AGENT)
                
                with urllib.request.urlopen(request, timeout=timeout) as response:
                    content = response.read().decode("utf-8")
                    logger.debug(f"Successfully downloaded from: {url}")
                    return True, url, content
                    
            except urllib.error.URLError as e:
                logger.debug(f"URL error from {url}: {e}")
                continue
            except Exception as e:
                logger.debug(f"Download error from {url}: {e}")
                continue
        
        return False, None, None

    def _download_database(self):
        """å°è¯•ä»é•œåƒåœ°å€ä¸‹è½½æ•°æ®åº“"""
        import urllib.error
        import urllib.request

        for url in COMMUNITY_DB_URLS:
            try:
                logger.debug(f"Trying to download from: {url}")
                request = urllib.request.Request(url)
                request.add_header("User-Agent", USER_AGENT)

                with urllib.request.urlopen(
                    request, timeout=NETWORK_TIMEOUT_SECONDS
                ) as response:
                    content = response.read().decode("utf-8")
                    logger.debug(f"Successfully downloaded from: {url}")
                    return True, url, content
            except urllib.error.URLError as e:
                logger.debug(f"Failed to download from {url}: {e}")
                continue
            except Exception as e:
                logger.debug(f"Error downloading from {url}: {e}")
                continue

        return False, None, None

    def _update_check_timestamp(self):
        """æ›´æ–°æ£€æŸ¥æ—¶é—´æˆ³è€Œä¸ä¿®æ”¹ç‰ˆæœ¬ä¿¡æ¯"""
        try:
            # å¦‚æœç‰ˆæœ¬æ–‡ä»¶å­˜åœ¨ï¼Œåªæ›´æ–°æ—¶é—´æˆ³
            if self.community_version_path.exists():
                import os
                import time

                current_time = time.time()
                os.utime(self.community_version_path, (current_time, current_time))
        except Exception as e:
            logger.error(f"Failed to update timestamp: {e}")

    def _update_version_info(self, source_url, version=None):
        """æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯"""
        try:
            with open(self.community_version_path, "w") as f:
                f.write(f"Updated: {datetime.now().isoformat()}\n")
                f.write(f"Source: {source_url}\n")
                if version:
                    f.write(f"Version: {version}\n")
                else:
                    f.write(f"Version: {datetime.now().strftime('%Y.%m.%d')}\n")
        except Exception as e:
            logger.error(f"Failed to update version info: {e}")

    def force_update_community_db(self):
        """å¼ºåˆ¶æ›´æ–°ç¤¾åŒºæ•°æ®åº“ï¼Œå¿½ç•¥æ—¶é—´æ£€æŸ¥"""
        # æ ‡è®°ä¸ºå¼ºåˆ¶æ›´æ–°ï¼Œè·³è¿‡æ—¶é—´æ£€æŸ¥ä½†ä¿ç•™ç‰ˆæœ¬æ¯”è¾ƒ
        self._force_update = True
        try:
            self.check_community_updates()
        finally:
            self._force_update = False

    def is_steam_running(self):
        """æ£€æŸ¥ Steam æ˜¯å¦æ­£åœ¨è¿è¡Œ"""
        try:
            result = subprocess.run(
                ["pgrep", "-x", "steam"], capture_output=True, text=True
            )
            return result.returncode == 0
        except Exception as e:
            logger.error(f"Error checking if Steam is running: {e}")
            return False

    def get_steam_user_dirs(self):
        """è·å–æ‰€æœ‰ Steam ç”¨æˆ·ç›®å½•"""
        userdata_dir = self.steam_dir / "userdata"
        if not userdata_dir.exists():
            return []
        return [d for d in userdata_dir.iterdir() if d.is_dir() and d.name.isdigit()]

    def load_vdf_file(self, file_path):
        """å®‰å…¨åŠ è½½VDFæ–‡ä»¶ï¼Œæ”¯æŒæ–‡æœ¬å’ŒäºŒè¿›åˆ¶æ ¼å¼"""
        try:
            # å…ˆå°è¯•æ–‡æœ¬æ ¼å¼
            with open(file_path, "r", encoding="utf-8") as f:
                return vdf.load(f), "text"
        except (UnicodeDecodeError, Exception):
            try:
                # å†å°è¯•äºŒè¿›åˆ¶æ ¼å¼
                with open(file_path, "rb") as f:
                    return vdf.binary_load(f), "binary"
            except Exception as e:
                raise Exception(f"Failed to parse VDF file {file_path}: {e}")

    def save_vdf_file(self, file_path, data, format_type):
        """ä¿å­˜VDFæ–‡ä»¶ï¼Œä¿æŒåŸæ ¼å¼"""
        if format_type == "text":
            with open(file_path, "w", encoding="utf-8") as f:
                vdf.dump(data, f, pretty=True)
        else:
            with open(file_path, "wb") as f:
                f.write(vdf.binary_dumps(data))

    def parse_current_params(self, current_options):
        """è§£æå½“å‰å¯åŠ¨å‚æ•°ä¸ºå‰ç½®å’Œåç½®éƒ¨åˆ†
        
        æ”¯æŒå¤§å°å†™ä¸æ•æ„Ÿçš„ %command% å ä½ç¬¦æ£€æµ‹
        Steam ä¸­å¯èƒ½å‡ºç° %command%ã€%COMMAND% ç­‰ä¸åŒå¤§å°å†™å½¢å¼
        """
        if not current_options:
            return [], ""

        # æŸ¥æ‰¾ %command% å ä½ç¬¦ï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰
        # Steam å¯èƒ½ä½¿ç”¨ä¸åŒå¤§å°å†™çš„ %command%ï¼Œå¦‚ %COMMAND%
        command_pattern = re.compile(r'%command%', re.IGNORECASE)
        match = command_pattern.search(current_options)
        
        if not match:
            # å¦‚æœæ²¡æœ‰æ‰¾åˆ° %command% å ä½ç¬¦ï¼Œå°†æ•´ä¸ªå­—ç¬¦ä¸²è§†ä¸ºåç½®å‚æ•°
            return [], current_options.strip()

        # ä½¿ç”¨æ‰¾åˆ°çš„å®é™…å ä½ç¬¦è¿›è¡Œåˆ†å‰²
        command_placeholder = match.group()
        parts = current_options.split(command_placeholder, 1)
        prefix_part = parts[0].strip()
        suffix_part = parts[1].strip() if len(parts) > 1 else ""

        prefix_params = prefix_part.split() if prefix_part else []
        return prefix_params, suffix_part

    def are_configs_equivalent(self, current_options, new_options):
        """æ£€æŸ¥ä¸¤ä¸ªé…ç½®æ˜¯å¦å®è´¨ç›¸åŒï¼ˆå¿½ç•¥ä»…æ·»åŠ %command%çš„æƒ…å†µï¼‰"""
        if current_options == new_options:
            return True
        
        # è§„èŒƒåŒ–å¤„ç†ï¼ˆå»é™¤å¤šä½™ç©ºæ ¼ï¼Œç»Ÿä¸€%command%æ ¼å¼ï¼‰
        def normalize_config(config):
            if not config:
                return ""
            # è§„èŒƒåŒ–%command%å‘¨å›´çš„ç©ºæ ¼
            normalized = re.sub(r'\s*%command%\s*', ' %command% ', config, flags=re.IGNORECASE)
            # æ¸…ç†å¤šä½™ç©ºæ ¼
            normalized = ' '.join(normalized.split())
            return normalized.strip()
        
        normalized_current = normalize_config(current_options)
        normalized_new = normalize_config(new_options)
        
        if normalized_current == normalized_new:
            return True
        
        # è§£æä¸¤ä¸ªé…ç½®
        curr_prefix, curr_suffix = self.parse_current_params(current_options)
        new_prefix, new_suffix = self.parse_current_params(new_options)
        
        # å¦‚æœå‰ç½®å‚æ•°ä¸ºç©ºä¸”åç½®å‚æ•°ç›¸åŒï¼Œè§†ä¸ºç­‰ä»·
        if not curr_prefix and not new_prefix and curr_suffix == new_suffix:
            return True
            
        # ç‰¹æ®Šæƒ…å†µï¼šå½“å‰æ²¡æœ‰%command%ï¼Œæ–°é…ç½®åªæ˜¯æ·»åŠ äº†%command%ä½†å‚æ•°å†…å®¹ç›¸åŒ
        if not current_options.strip():
            return new_options == COMMAND_PLACEHOLDER
        
        if COMMAND_PLACEHOLDER not in current_options and COMMAND_PLACEHOLDER in new_options:
            # æ£€æŸ¥æ˜¯å¦åªæ˜¯åœ¨ç›¸åŒå†…å®¹å‰æ·»åŠ äº†%command%
            expected_new = f"{COMMAND_PLACEHOLDER} {current_options}".strip()
            if new_options == expected_new:
                return True
        
        return False


    def merge_prefix_params(self, user_prefix, config_prefix, user_handling, conflicts):
        """åˆå¹¶å‰ç½®å‚æ•°"""
        managed_params = config_prefix.get("params", [])
        preserve = user_handling.get("preserve", True)
        position = user_handling.get("position", "before")

        if not preserve:
            return managed_params

        # å¤„ç†å†²çªè§„åˆ™
        final_user_params = user_prefix.copy()
        replace_keys = conflicts.get("replace_keys", [])
        merge_keys = conflicts.get("merge_keys", {})

        # æ„å»ºç¯å¢ƒå˜é‡å­—å…¸ç”¨äºå†²çªå¤„ç†
        user_env = {}
        managed_env = {}

        # è§£æç”¨æˆ·çš„ç¯å¢ƒå˜é‡
        user_non_env = []
        for param in final_user_params:
            if "=" in param and not param.startswith("-"):
                key, value = param.split("=", 1)
                user_env[key] = value
            else:
                user_non_env.append(param)

        # è§£æç®¡ç†çš„ç¯å¢ƒå˜é‡
        managed_non_env = []
        for param in managed_params:
            if "=" in param and not param.startswith("-"):
                key, value = param.split("=", 1)
                managed_env[key] = value
            else:
                managed_non_env.append(param)

        # å¤„ç†ç¯å¢ƒå˜é‡å†²çª
        final_env = user_env.copy()

        # æ›¿æ¢è§„åˆ™ï¼šå¼ºåˆ¶ä½¿ç”¨ç®¡ç†çš„å€¼
        for key in replace_keys:
            if key in managed_env:
                final_env[key] = managed_env[key]

        # æ·»åŠ ç®¡ç†çš„æ–°ç¯å¢ƒå˜é‡
        for key, value in managed_env.items():
            if key not in final_env:
                final_env[key] = value

        # å¤„ç†è·¯å¾„åˆå¹¶
        for key, merge_type in merge_keys.items():
            if key in managed_env and key in user_env:
                if merge_type == "prepend":
                    final_env[key] = f"{managed_env[key]}:{user_env[key]}"
                elif merge_type == "append":
                    final_env[key] = f"{user_env[key]}:{managed_env[key]}"

        # é‡å»ºå‚æ•°åˆ—è¡¨
        env_params = [f"{k}={v}" for k, v in final_env.items()]

        if position == "before":
            all_params = env_params + user_non_env + managed_non_env
        elif position == "after":
            all_params = managed_non_env + env_params + user_non_env
        else:  # replace
            all_params = env_params + managed_non_env
        
        # å»é‡ä½†ä¿æŒé¡ºåºï¼ˆå¯¹éç¯å¢ƒå˜é‡å‚æ•°ï¼‰
        final_params = []
        seen = set()
        for param in all_params:
            if param not in seen:
                final_params.append(param)
                seen.add(param)
        
        return final_params

    def merge_suffix_params(self, user_suffix, config_suffix, user_handling, conflicts):
        """åˆå¹¶åç½®å‚æ•°"""
        managed_params = config_suffix.get("params", [])
        preserve = user_handling.get("preserve", True)
        position = user_handling.get("position", "before")

        user_params = user_suffix.split() if user_suffix else []

        if not preserve:
            final_params = managed_params
        else:
            # å¤„ç†æ›¿æ¢è§„åˆ™
            replace_rules = conflicts.get("replace_rules", {})
            processed_user_params = []

            for param in user_params:
                if param in replace_rules:
                    replacement = replace_rules[param]
                    if replacement:  # å¦‚æœæ›¿æ¢å€¼ä¸ä¸ºç©º
                        processed_user_params.append(replacement)
                    # å¦‚æœæ›¿æ¢å€¼ä¸ºç©ºï¼Œåˆ™è·³è¿‡ï¼ˆåˆ é™¤è¯¥å‚æ•°ï¼‰
                else:
                    processed_user_params.append(param)

            # æŒ‰ä½ç½®åˆå¹¶å‚æ•°ï¼Œå»é‡
            if position == "before":
                all_params = processed_user_params + managed_params
            elif position == "after":
                all_params = managed_params + processed_user_params
            else:  # replace
                all_params = managed_params
            
            # å»é‡ä½†ä¿æŒé¡ºåº
            final_params = []
            seen = set()
            for param in all_params:
                if param not in seen:
                    final_params.append(param)
                    seen.add(param)

        return " ".join(final_params)

    def calculate_launch_options(self, current_options, game_config):
        """ç»Ÿä¸€çš„å¯åŠ¨é€‰é¡¹è®¡ç®—é€»è¾‘
        
        æ¶ˆé™¤ apply_game_config() å’Œ show_diff() ä¸­çš„é‡å¤ä»£ç 
        ä¿æŒä¸åŸå§‹å®ç°100%åŠŸèƒ½ä¸€è‡´
        """
        config_type = game_config.get("type", "simple")
        
        if config_type in ["script", "template", "raw"]:
            # ä½¿ç”¨æ–°çš„å¤„ç†å™¨å¤„ç†å¤æ‚é…ç½®
            return self.launch_option_handler.apply_config_by_type(current_options, game_config)
        elif self.launch_option_handler.detect_option_type(current_options) == "script":
            # ç”¨æˆ·å·²ç»åœ¨ä½¿ç”¨è„šæœ¬é…ç½®ï¼Œè·³è¿‡ç®¡ç†
            return current_options
        else:
            # ä½¿ç”¨ä¼ ç»Ÿçš„å‰ç½®/åç½®å‚æ•°å¤„ç†
            user_prefix, user_suffix = self.parse_current_params(current_options)

            # å¤„ç†å‰ç½®å‚æ•°
            prefix_config = game_config.get("prefix", {})
            final_prefix = self.merge_prefix_params(
                user_prefix,
                prefix_config,
                prefix_config.get("user_handling", {}),
                prefix_config.get("conflicts", {}),
            )

            # å¤„ç†åç½®å‚æ•°
            suffix_config = game_config.get("suffix", {})
            final_suffix = self.merge_suffix_params(
                user_suffix,
                suffix_config,
                suffix_config.get("user_handling", {}),
                suffix_config.get("conflicts", {}),
            )

            # æ„å»ºæœ€ç»ˆå‚æ•°
            if final_prefix and final_suffix:
                return f"{' '.join(final_prefix)} {COMMAND_PLACEHOLDER} {final_suffix}"
            elif final_prefix:
                return f"{' '.join(final_prefix)} {COMMAND_PLACEHOLDER}"
            elif final_suffix:
                return f"{COMMAND_PLACEHOLDER} {final_suffix}"
            else:
                return COMMAND_PLACEHOLDER

    def apply_game_config(self, app_id, dry_run=False, verbose=True):
        """åº”ç”¨å•ä¸ªæ¸¸æˆçš„é…ç½®"""
        game_config, config_source = self.get_game_config(app_id, verbose=verbose)
        if not game_config:
            if verbose:
                logger.warning(f"No config found for app {app_id}")
            return False

        # æ£€æŸ¥ Steam æ˜¯å¦æ­£åœ¨è¿è¡Œ
        if verbose and not dry_run and self.is_steam_running():
            logger.warning(
                "Warning: Steam is running. Changes may not take effect until Steam is restarted."
            )
            logger.warning("Consider stopping Steam first with: steam -shutdown")

        success = False
        for user_dir in self.get_steam_user_dirs():
            localconfig_path = user_dir / "config" / "localconfig.vdf"

            if not localconfig_path.exists():
                continue

            # è¯»å–å½“å‰é…ç½®
            data, vdf_format = self.load_vdf_file(localconfig_path)

            apps = (
                data.get("UserLocalConfigStore", {})
                .get("Software", {})
                .get("Valve", {})
                .get("Steam", {})
                .get("apps", {})
            )
            current_options = apps.get(app_id, {}).get("LaunchOptions", "")

            # å¤‡ä»½åŸå§‹é…ç½®
            if self.custom_config.get("global", {}).get("backup_enabled", True):
                self.backup_config(app_id, current_options)

            # è®¡ç®—æ–°çš„å¯åŠ¨é€‰é¡¹
            new_options = self.calculate_launch_options(current_options, game_config)

            # æ˜¾ç¤ºå˜æ›´
            if not self.are_configs_equivalent(current_options, new_options):
                if verbose:
                    print(f"\nApp {app_id} ({game_config.get('name', 'Unknown')}):")
                    print(f"  Before: {current_options or '(empty)'}")
                    print(f"  After:  {new_options}")
                else:
                    print(f"ğŸ”§ {game_config.get('name', f'App {app_id}')}")
                    print(f"   Before: {current_options or '(empty)'}")
                    print(f"   After:  {new_options}")

                if not dry_run:
                    # å¤‡ä»½åŸå§‹é…ç½®
                    if self.custom_config.get("global", {}).get("backup_enabled", True):
                        self.backup_config(app_id, current_options)
                    
                    # åº”ç”¨æ›´æ”¹
                    if app_id not in apps:
                        apps[app_id] = {}
                    apps[app_id]["LaunchOptions"] = new_options

                    # ä¿å­˜æ–‡ä»¶
                    self.save_vdf_file(localconfig_path, data, vdf_format)

                    success = True
            else:
                if verbose:
                    print(f"App {app_id}: No changes needed")

        return success



    def backup_config(self, app_id, current_options):
        """å¤‡ä»½å½“å‰é…ç½®"""
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        backup_file = (
            self.backup_dir
            / f"app_{app_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        )

        with open(backup_file, "w") as f:
            f.write(f"# Backup for Steam App {app_id}\n")
            f.write(f"# Created: {datetime.now()}\n")
            f.write("# Original launch options:\n")
            f.write(current_options or "(empty)")

    def apply_all_configs(self, dry_run=False):
        """åº”ç”¨æ‰€æœ‰æ¸¸æˆé…ç½®"""
        # åˆå¹¶ç”¨æˆ·é…ç½®å’Œç¤¾åŒºé…ç½®ä¸­çš„æ‰€æœ‰æ¸¸æˆ
        all_games = set()
        all_games.update(self.custom_config.get("games", {}).keys())
        all_games.update(self.community_config.get("games", {}).keys())

        if not all_games:
            print("No game configurations found")
            return

        print(f"Applying configurations for {len(all_games)} games...")
        if dry_run:
            print("DRY RUN MODE - No changes will be made")

        changed_count = 0
        skipped_count = 0
        
        for app_id in all_games:
            if app_id.startswith("example_"):
                continue  # è·³è¿‡ç¤ºä¾‹é…ç½®
            
            # ç®€æ´æ¨¡å¼åº”ç”¨å•ä¸ªæ¸¸æˆé…ç½®
            success = self.apply_game_config(app_id, dry_run, verbose=False)
            if success:
                changed_count += 1
            else:
                skipped_count += 1
        
        # æ€»ç»“
        print(f"\nğŸ“Š Summary:")
        print(f"   âœ… {changed_count} games updated")
        print(f"   âšª {skipped_count} games no changes needed")

    def show_diff(self, app_id):
        """æ˜¾ç¤ºé…ç½®å·®å¼‚å¯¹æ¯”"""
        game_config, config_source = self.get_game_config(app_id)
        if not game_config:
            print(f"No config found for app {app_id}")
            return False

        print(
            f"Configuration diff for app {app_id} ({game_config.get('name', 'Unknown')}):"
        )
        print("=" * 60)

        for user_dir in self.get_steam_user_dirs():
            localconfig_path = user_dir / "config" / "localconfig.vdf"

            if not localconfig_path.exists():
                continue

            # è¯»å–å½“å‰é…ç½®
            data, vdf_format = self.load_vdf_file(localconfig_path)

            apps = (
                data.get("UserLocalConfigStore", {})
                .get("Software", {})
                .get("Valve", {})
                .get("Steam", {})
                .get("apps", {})
            )
            current_options = apps.get(app_id, {}).get("LaunchOptions", "")

            # è®¡ç®—æ–°çš„å¯åŠ¨é€‰é¡¹
            new_options = self.calculate_launch_options(current_options, game_config)

            # æ£€æŸ¥æ˜¯å¦æœ‰å®è´¨æ€§å˜åŒ–
            if not self.are_configs_equivalent(current_options, new_options):
                # æ˜¾ç¤ºè¯¦ç»†å·®å¼‚
                print("\nğŸ“‹ Current configuration:")
                print(f"   {current_options or '(empty)'}")

                print("\nğŸ¯ Proposed configuration:")
                print(f"   {new_options}")
                print("\nğŸ”„ Changes:")

                # åˆ†æå…·ä½“å˜åŒ–
                if not current_options:
                    print(f"   + Will add: {new_options}")
                elif new_options == COMMAND_PLACEHOLDER:
                    print("   - Will remove all launch options")
                elif game_config.get("type") in ["script", "template", "raw"]:
                    # å¤æ‚é…ç½®ç±»å‹çš„ç®€åŒ–æ˜¾ç¤º
                    config_type = game_config.get("type", "simple")
                    print(f"   ğŸ”§ Configuration type: {config_type}")
                    if game_config.get("description"):
                        print(f"   ğŸ“ Description: {game_config['description']}")
                    print(f"   - Current: {current_options or '(empty)'}")
                    print(f"   + Proposed: {new_options}")
                else:
                    # è§£æå½“å‰å’Œæ–°çš„å‚æ•°è¿›è¡Œè¯¦ç»†å¯¹æ¯”ï¼ˆç®€å•æ¨¡å¼ï¼‰
                    curr_prefix, curr_suffix = self.parse_current_params(
                        current_options
                    )
                    new_prefix, new_suffix = self.parse_current_params(new_options)

                    if curr_prefix != new_prefix:
                        print("   ğŸ“¦ Environment variables:")
                        if curr_prefix:
                            print(f"      - Current: {' '.join(curr_prefix)}")
                        else:
                            print("      - Current: (none)")
                        if new_prefix:
                            print(f"      + Proposed: {' '.join(new_prefix)}")
                        else:
                            print("      + Proposed: (none)")

                    if curr_suffix != new_suffix:
                        print("   ğŸš€ Launch parameters:")
                        if curr_suffix:
                            print(f"      - Current: {curr_suffix}")
                        else:
                            print("      - Current: (none)")
                        if new_suffix:
                            print(f"      + Proposed: {new_suffix}")
                        else:
                            print("      + Proposed: (none)")
            else:
                print("\nâœ… No changes needed - configuration is already up to date")

            print("\n" + "=" * 60)
            return True

        return False

    def validate_config(self):
        """éªŒè¯é…ç½®æ–‡ä»¶"""
        print("Validating configuration...")

        issues = []

        # éªŒè¯ç”¨æˆ·é…ç½®
        custom_games = self.custom_config.get("games", {})
        for app_id, game_config in custom_games.items():
            if not app_id.isdigit() and not app_id.startswith("example_"):
                issues.append(f"Custom config - App ID '{app_id}' should be numeric")

            # æ£€æŸ¥å¿…éœ€å­—æ®µ
            if "prefix" not in game_config and "suffix" not in game_config:
                issues.append(
                    f"Custom config - App {app_id}: No prefix or suffix configuration"
                )

        # éªŒè¯ç¤¾åŒºé…ç½®ï¼ˆåªæ£€æŸ¥æ ¼å¼ï¼Œä¸æ£€æŸ¥å†…å®¹ï¼‰
        community_games = self.community_config.get("games", {})
        print(
            f"Found {len(custom_games)} custom configs and {len(community_games)} community configs"
        )

        if issues:
            print("Configuration issues found:")
            for issue in issues:
                print(f"  - {issue}")
        else:
            print("Configuration is valid!")

    def update_community_db(self):
        """æ‰‹åŠ¨æ›´æ–°ç¤¾åŒºæ•°æ®åº“"""
        print("Manually updating community database...")
        self.force_update_community_db()
        print("Update completed!")


def main():
    parser = argparse.ArgumentParser(description="Steam Launch Options Manager")
    parser.add_argument(
        "command",
        choices=[
            "apply",
            "apply-all",
            "dry-run",
            "diff",
            "validate",
            "init",
            "update-db",
        ],
        help="Command to execute",
    )
    parser.add_argument("app_id", nargs="?", help="Steam App ID")
    parser.add_argument(
        "--config",
        default="~/.config/steam-launch-manager",
        help="Configuration file path",
    )
    parser.add_argument(
        "--dry-run", action="store_true", help="Preview changes without applying"
    )

    args = parser.parse_args()

    if args.command == "init":
        # åˆ›å»ºå¯¹è±¡æ—¶ä¼šè‡ªåŠ¨åˆå§‹åŒ–ç›®å½•å’Œé…ç½®æ–‡ä»¶
        manager = SteamLaunchManager(args.config)
        print("Configuration file created/updated")
        return

    manager = SteamLaunchManager(args.config)

    if args.command == "update-db":
        manager.update_community_db()
        return

    if args.command == "validate":
        manager.validate_config()
        return

    if args.command == "apply-all":
        manager.apply_all_configs(dry_run=args.dry_run)
        return

    if not args.app_id:
        logger.error("App ID is required for this command")
        return

    if args.command == "apply":
        manager.apply_game_config(args.app_id, dry_run=args.dry_run)
    elif args.command == "dry-run":
        manager.apply_game_config(args.app_id, dry_run=True)
    elif args.command == "diff":
        manager.show_diff(args.app_id)


if __name__ == "__main__":
    main()
