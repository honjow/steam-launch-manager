#!/usr/bin/env python3
"""
Steam Launch Options Manager
æ™ºèƒ½ç®¡ç† Steam æ¸¸æˆå¯åŠ¨å‚æ•°ï¼Œæ”¯æŒå‰ç½®/åç½®å‚æ•°åˆå¹¶å’Œå†²çªå¤„ç†
"""

import argparse
import subprocess
import sys
from datetime import datetime
from pathlib import Path

import yaml

try:
    import vdf
except ImportError:
    print("Error: python-vdf library is required. Install with: pip install vdf")
    sys.exit(1)

# =============================================================================
# é…ç½®å‚æ•° - Configuration Parameters
# =============================================================================

# ç¤¾åŒºæ•°æ®åº“æ›´æ–°é…ç½®
COMMUNITY_DB_URLS = [
    "https://cdn.jsdelivr.net/gh/honjow/steam-launch-manager@master/src/data/games-db.yaml",  # CDNé•œåƒ
    "https://raw.githubusercontent.com/honjow/steam-launch-manager/refs/heads/master/src/data/games-db.yaml",
    "https://gitee.com/honjow/steam-launch-manager/raw/master/src/data/games-db.yaml",  # é•œåƒåœ°å€
]
VERSION_CHECK_URLS = [
    "https://cdn.jsdelivr.net/gh/honjow/steam-launch-manager@master/src/data/VERSION",
    "https://raw.githubusercontent.com/honjow/steam-launch-manager/refs/heads/master/src/data/VERSION",
    "https://gitee.com/honjow/steam-launch-manager/raw/master/src/data/VERSION",
]
UPDATE_CHECK_INTERVAL_HOURS = 24  # æ£€æŸ¥æ›´æ–°é—´éš”ï¼ˆå°æ—¶ï¼‰
NETWORK_TIMEOUT_SECONDS = 10  # ç½‘ç»œè¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
USER_AGENT = "steam-launch-manager/1.0"  # ç”¨æˆ·ä»£ç†å­—ç¬¦ä¸²

# é»˜è®¤é…ç½®è·¯å¾„
DEFAULT_CONFIG_PATH = "~/.config/steam-launch-manager"
DEFAULT_STEAM_PATH = "~/.local/share/Steam"
DEFAULT_BACKUP_PATH = "~/.config/steam-backups"


class SteamLaunchManager:
    def __init__(self, config_path=None):
        if config_path is None:
            config_path = DEFAULT_CONFIG_PATH

        self.config_dir = Path(config_path).expanduser()
        self.custom_config_path = self.config_dir / "custom" / "games.yaml"
        self.community_config_path = self.config_dir / "community" / "games.yaml"
        self.community_version_path = self.config_dir / "community" / "version.txt"

        # ç¡®ä¿ç›®å½•å­˜åœ¨
        self.config_dir.mkdir(parents=True, exist_ok=True)
        (self.config_dir / "custom").mkdir(exist_ok=True)
        (self.config_dir / "community").mkdir(exist_ok=True)

        # åŠ è½½é…ç½®
        self.custom_config = self.load_custom_config()
        self.community_config = self.load_community_config()

        # æ£€æŸ¥ç¤¾åŒºé…ç½®æ›´æ–°
        self.check_community_updates()

        # ä½¿ç”¨é…ç½®æ–‡ä»¶ä¸­çš„steam_dirï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤å€¼
        config_steam_dir = self.custom_config.get("global", {}).get("steam_dir")
        if config_steam_dir:
            self.steam_dir = Path(config_steam_dir).expanduser()
        else:
            self.steam_dir = Path(DEFAULT_STEAM_PATH).expanduser()

        self.backup_dir = Path(
            self.custom_config.get("global", {}).get("backup_path", DEFAULT_BACKUP_PATH)
        ).expanduser()

    def load_custom_config(self):
        """åŠ è½½ç”¨æˆ·è‡ªå®šä¹‰é…ç½®"""
        if not self.custom_config_path.exists():
            self.create_default_custom_config()

        with open(self.custom_config_path) as f:
            return yaml.safe_load(f) or {}

    def load_community_config(self):
        """åŠ è½½ç¤¾åŒºé¢„è®¾é…ç½®"""
        if not self.community_config_path.exists():
            return {"games": {}}

        with open(self.community_config_path) as f:
            return yaml.safe_load(f) or {"games": {}}

    def create_default_custom_config(self):
        """åˆ›å»ºé»˜è®¤çš„ç”¨æˆ·è‡ªå®šä¹‰é…ç½®æ–‡ä»¶"""
        default_config = {
            "global": {
                "backup_enabled": True,
                "backup_path": DEFAULT_BACKUP_PATH,
                "dry_run": False,
                "auto_update_community_db": True,
            },
            "games": {
                # ç”¨æˆ·å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ è‡ªå·±çš„æ¸¸æˆé…ç½®
                # ç¤ºä¾‹ï¼ˆå¯ä»¥åˆ é™¤ï¼‰:
                # "730": {
                #     "name": "Counter-Strike 2 - Custom",
                #     "prefix": {
                #         "params": ["RADV_PERFTEST=aco"]
                #     }
                # }
            },
        }

        self.custom_config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.custom_config_path, "w") as f:
            yaml.dump(default_config, f, default_flow_style=False, indent=2)

        print(f"Created custom config at: {self.custom_config_path}")
        return default_config

    def get_game_config(self, app_id):
        """è·å–æ¸¸æˆé…ç½®ï¼šç”¨æˆ·é…ç½®ä¼˜å…ˆäºç¤¾åŒºé…ç½®"""
        # 1. æ£€æŸ¥ç”¨æˆ·è‡ªå®šä¹‰é…ç½®
        custom_games = self.custom_config.get("games", {})
        if app_id in custom_games:
            print(f"Using custom config for {app_id}")
            return custom_games[app_id], "custom"

        # 2. ä½¿ç”¨ç¤¾åŒºé¢„è®¾é…ç½®
        community_games = self.community_config.get("games", {})
        if app_id in community_games:
            print(f"Using community config for {app_id}")
            return community_games[app_id], "community"

        # 3. æ²¡æœ‰é…ç½®
        return None, None

    def check_community_updates(self):
        """æ£€æŸ¥å¹¶æ›´æ–°ç¤¾åŒºé…ç½®æ•°æ®åº“"""
        auto_update = self.custom_config.get("global", {}).get(
            "auto_update_community_db", True
        )
        if not auto_update:
            return

        try:
            # æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
            if self._should_update_database():
                print("Checking for community database updates...")

                # é¦–å…ˆå°è¯•ç‰ˆæœ¬æ£€æŸ¥
                remote_version = self._get_remote_version()
                local_version = self._get_local_version()

                if remote_version and local_version and remote_version == local_version:
                    print(f"Database is up to date (version: {local_version})")
                    self._update_check_timestamp()  # æ›´æ–°æ£€æŸ¥æ—¶é—´æˆ³
                    return

                if remote_version:
                    print(
                        f"New version available: {remote_version} (current: {local_version or 'none'})"
                    )

                # ä¸‹è½½æ–°æ•°æ®åº“
                success, db_url, content = self._download_database()
                if success:
                    # éªŒè¯ä¸‹è½½çš„å†…å®¹æ˜¯å¦ä¸ºæœ‰æ•ˆçš„YAML
                    try:
                        yaml.safe_load(content)
                    except yaml.YAMLError as e:
                        print(f"Downloaded content is not valid YAML: {e}")
                        return

                    # ä¿å­˜æ–°æ•°æ®åº“
                    with open(self.community_config_path, "w", encoding="utf-8") as f:
                        f.write(content)

                    # æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯
                    self._update_version_info(db_url, remote_version)

                    print("Community database updated successfully")

                    # é‡æ–°åŠ è½½ç¤¾åŒºé…ç½®
                    self.community_config = self.load_community_config()
                else:
                    print("Failed to download community database from all sources")
                    print("Using local cache if available")

        except Exception as e:
            print(f"Failed to check community updates: {e}")

    def _should_update_database(self):
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥æ›´æ–°æ•°æ®åº“"""
        # å¦‚æœæ˜¯å¼ºåˆ¶æ›´æ–°ï¼Œè·³è¿‡æ—¶é—´æ£€æŸ¥ä½†ä»è¿›è¡Œç‰ˆæœ¬æ¯”è¾ƒ
        if hasattr(self, "_force_update") and self._force_update:
            return True

        # å¦‚æœç¤¾åŒºé…ç½®ä¸å­˜åœ¨ï¼Œéœ€è¦æ›´æ–°
        if not self.community_config_path.exists():
            return True

        # æ£€æŸ¥ä¸Šæ¬¡æ›´æ–°æ—¶é—´
        if not self.community_version_path.exists():
            return True

        try:
            import time

            # è·å–æ–‡ä»¶æœ€åä¿®æ”¹æ—¶é—´
            last_modified = self.community_version_path.stat().st_mtime
            current_time = time.time()

            # å¦‚æœè¶…è¿‡æŒ‡å®šå°æ—¶æ•°æ²¡æ›´æ–°ï¼Œåˆ™éœ€è¦æ›´æ–°
            if current_time - last_modified > UPDATE_CHECK_INTERVAL_HOURS * 3600:
                return True

        except Exception:
            return True

        return False

    def _get_remote_version(self):
        """è·å–è¿œç¨‹ç‰ˆæœ¬ä¿¡æ¯"""
        import urllib.error
        import urllib.request

        for url in VERSION_CHECK_URLS:
            try:
                request = urllib.request.Request(url)
                request.add_header("User-Agent", USER_AGENT)

                with urllib.request.urlopen(
                    request, timeout=NETWORK_TIMEOUT_SECONDS
                ) as response:
                    version = response.read().decode("utf-8").strip()
                    if version:
                        return version
            except (urllib.error.URLError, Exception):
                continue
        return None

    def _get_local_version(self):
        """è·å–æœ¬åœ°ç‰ˆæœ¬ä¿¡æ¯"""
        try:
            if self.community_version_path.exists():
                with open(self.community_version_path, "r") as f:
                    lines = f.readlines()
                    for line in lines:
                        if line.startswith("Version: "):
                            return line.split("Version: ", 1)[1].strip()
        except Exception:
            pass
        return None

    def _download_database(self):
        """å°è¯•ä»é•œåƒåœ°å€ä¸‹è½½æ•°æ®åº“"""
        import urllib.error
        import urllib.request

        for url in COMMUNITY_DB_URLS:
            try:
                print(f"Trying to download from: {url}")
                request = urllib.request.Request(url)
                request.add_header("User-Agent", USER_AGENT)

                with urllib.request.urlopen(
                    request, timeout=NETWORK_TIMEOUT_SECONDS
                ) as response:
                    content = response.read().decode("utf-8")
                    print(f"Successfully downloaded from: {url}")
                    return True, url, content
            except urllib.error.URLError as e:
                print(f"Failed to download from {url}: {e}")
                continue
            except Exception as e:
                print(f"Error downloading from {url}: {e}")
                continue

        return False, None, None

    def _update_check_timestamp(self):
        """æ›´æ–°æ£€æŸ¥æ—¶é—´æˆ³è€Œä¸ä¿®æ”¹ç‰ˆæœ¬ä¿¡æ¯"""
        try:
            # å¦‚æœç‰ˆæœ¬æ–‡ä»¶å­˜åœ¨ï¼Œåªæ›´æ–°æ—¶é—´æˆ³
            if self.community_version_path.exists():
                import os
                import time

                current_time = time.time()
                os.utime(self.community_version_path, (current_time, current_time))
        except Exception as e:
            print(f"Failed to update timestamp: {e}")

    def _update_version_info(self, source_url, version=None):
        """æ›´æ–°ç‰ˆæœ¬ä¿¡æ¯"""
        try:
            with open(self.community_version_path, "w") as f:
                f.write(f"Updated: {datetime.now().isoformat()}\n")
                f.write(f"Source: {source_url}\n")
                if version:
                    f.write(f"Version: {version}\n")
                else:
                    f.write(f"Version: {datetime.now().strftime('%Y.%m.%d')}\n")
        except Exception as e:
            print(f"Failed to update version info: {e}")

    def force_update_community_db(self):
        """å¼ºåˆ¶æ›´æ–°ç¤¾åŒºæ•°æ®åº“ï¼Œå¿½ç•¥æ—¶é—´æ£€æŸ¥"""
        # æ ‡è®°ä¸ºå¼ºåˆ¶æ›´æ–°ï¼Œè·³è¿‡æ—¶é—´æ£€æŸ¥ä½†ä¿ç•™ç‰ˆæœ¬æ¯”è¾ƒ
        self._force_update = True
        try:
            self.check_community_updates()
        finally:
            self._force_update = False

    def is_steam_running(self):
        """æ£€æŸ¥ Steam æ˜¯å¦æ­£åœ¨è¿è¡Œ"""
        try:
            result = subprocess.run(
                ["pgrep", "-x", "steam"], capture_output=True, text=True
            )
            return result.returncode == 0
        except Exception as e:
            print(f"Error checking if Steam is running: {e}")
            return False

    def get_steam_user_dirs(self):
        """è·å–æ‰€æœ‰ Steam ç”¨æˆ·ç›®å½•"""
        userdata_dir = self.steam_dir / "userdata"
        if not userdata_dir.exists():
            return []
        return [d for d in userdata_dir.iterdir() if d.is_dir() and d.name.isdigit()]

    def load_vdf_file(self, file_path):
        """å®‰å…¨åŠ è½½VDFæ–‡ä»¶ï¼Œæ”¯æŒæ–‡æœ¬å’ŒäºŒè¿›åˆ¶æ ¼å¼"""
        try:
            # å…ˆå°è¯•æ–‡æœ¬æ ¼å¼
            with open(file_path, "r", encoding="utf-8") as f:
                return vdf.load(f), "text"
        except (UnicodeDecodeError, vdf.VDFError):
            try:
                # å†å°è¯•äºŒè¿›åˆ¶æ ¼å¼
                with open(file_path, "rb") as f:
                    return vdf.binary_load(f), "binary"
            except vdf.VDFError as e:
                raise Exception(f"Failed to parse VDF file {file_path}: {e}")

    def save_vdf_file(self, file_path, data, format_type):
        """ä¿å­˜VDFæ–‡ä»¶ï¼Œä¿æŒåŸæ ¼å¼"""
        if format_type == "text":
            with open(file_path, "w", encoding="utf-8") as f:
                vdf.dump(data, f, pretty=True)
        else:
            with open(file_path, "wb") as f:
                f.write(vdf.binary_dumps(data))

    def parse_current_params(self, current_options):
        """è§£æå½“å‰å¯åŠ¨å‚æ•°ä¸ºå‰ç½®å’Œåç½®éƒ¨åˆ†"""
        if not current_options:
            return [], ""

        if "%command%" not in current_options:
            return [], current_options.strip()

        parts = current_options.split("%command%", 1)
        prefix_part = parts[0].strip()
        suffix_part = parts[1].strip() if len(parts) > 1 else ""

        prefix_params = prefix_part.split() if prefix_part else []
        return prefix_params, suffix_part

    def merge_prefix_params(self, user_prefix, config_prefix, user_handling, conflicts):
        """åˆå¹¶å‰ç½®å‚æ•°"""
        managed_params = config_prefix.get("params", [])
        preserve = user_handling.get("preserve", True)
        position = user_handling.get("position", "before")

        if not preserve:
            return managed_params

        # å¤„ç†å†²çªè§„åˆ™
        final_user_params = user_prefix.copy()
        replace_keys = conflicts.get("replace_keys", [])
        merge_keys = conflicts.get("merge_keys", {})

        # æ„å»ºç¯å¢ƒå˜é‡å­—å…¸ç”¨äºå†²çªå¤„ç†
        user_env = {}
        managed_env = {}

        # è§£æç”¨æˆ·çš„ç¯å¢ƒå˜é‡
        user_non_env = []
        for param in final_user_params:
            if "=" in param and not param.startswith("-"):
                key, value = param.split("=", 1)
                user_env[key] = value
            else:
                user_non_env.append(param)

        # è§£æç®¡ç†çš„ç¯å¢ƒå˜é‡
        managed_non_env = []
        for param in managed_params:
            if "=" in param and not param.startswith("-"):
                key, value = param.split("=", 1)
                managed_env[key] = value
            else:
                managed_non_env.append(param)

        # å¤„ç†ç¯å¢ƒå˜é‡å†²çª
        final_env = user_env.copy()

        # æ›¿æ¢è§„åˆ™ï¼šå¼ºåˆ¶ä½¿ç”¨ç®¡ç†çš„å€¼
        for key in replace_keys:
            if key in managed_env:
                final_env[key] = managed_env[key]

        # æ·»åŠ ç®¡ç†çš„æ–°ç¯å¢ƒå˜é‡
        for key, value in managed_env.items():
            if key not in final_env:
                final_env[key] = value

        # å¤„ç†è·¯å¾„åˆå¹¶
        for key, merge_type in merge_keys.items():
            if key in managed_env and key in user_env:
                if merge_type == "prepend":
                    final_env[key] = f"{managed_env[key]}:{user_env[key]}"
                elif merge_type == "append":
                    final_env[key] = f"{user_env[key]}:{managed_env[key]}"

        # é‡å»ºå‚æ•°åˆ—è¡¨
        env_params = [f"{k}={v}" for k, v in final_env.items()]

        if position == "before":
            return env_params + user_non_env + managed_non_env
        elif position == "after":
            return managed_non_env + env_params + user_non_env
        else:  # replace
            return env_params + managed_non_env

    def merge_suffix_params(self, user_suffix, config_suffix, user_handling, conflicts):
        """åˆå¹¶åç½®å‚æ•°"""
        managed_params = config_suffix.get("params", [])
        preserve = user_handling.get("preserve", True)
        position = user_handling.get("position", "before")

        user_params = user_suffix.split() if user_suffix else []

        if not preserve:
            final_params = managed_params
        else:
            # å¤„ç†æ›¿æ¢è§„åˆ™
            replace_rules = conflicts.get("replace_rules", {})
            processed_user_params = []

            for param in user_params:
                if param in replace_rules:
                    replacement = replace_rules[param]
                    if replacement:  # å¦‚æœæ›¿æ¢å€¼ä¸ä¸ºç©º
                        processed_user_params.append(replacement)
                    # å¦‚æœæ›¿æ¢å€¼ä¸ºç©ºï¼Œåˆ™è·³è¿‡ï¼ˆåˆ é™¤è¯¥å‚æ•°ï¼‰
                else:
                    processed_user_params.append(param)

            # æŒ‰ä½ç½®åˆå¹¶å‚æ•°
            if position == "before":
                final_params = processed_user_params + managed_params
            elif position == "after":
                final_params = managed_params + processed_user_params
            else:  # replace
                final_params = managed_params

        return " ".join(final_params)

    def apply_game_config(self, app_id, dry_run=False):
        """åº”ç”¨å•ä¸ªæ¸¸æˆçš„é…ç½®"""
        game_config, config_source = self.get_game_config(app_id)
        if not game_config:
            print(f"No config found for app {app_id}")
            return False

        # æ£€æŸ¥ Steam æ˜¯å¦æ­£åœ¨è¿è¡Œ
        if not dry_run and self.is_steam_running():
            print(
                "Warning: Steam is running. Changes may not take effect until Steam is restarted."
            )
            print("Consider stopping Steam first with: steam -shutdown")

        success = False
        for user_dir in self.get_steam_user_dirs():
            localconfig_path = user_dir / "config" / "localconfig.vdf"

            if not localconfig_path.exists():
                continue

            # è¯»å–å½“å‰é…ç½®
            data, vdf_format = self.load_vdf_file(localconfig_path)

            apps = (
                data.get("UserLocalConfigStore", {})
                .get("Software", {})
                .get("Valve", {})
                .get("Steam", {})
                .get("apps", {})
            )
            current_options = apps.get(app_id, {}).get("LaunchOptions", "")

            # å¤‡ä»½åŸå§‹é…ç½®
            if self.custom_config.get("global", {}).get("backup_enabled", True):
                self.backup_config(app_id, current_options)

            # è§£æå’Œåˆå¹¶å‚æ•°
            user_prefix, user_suffix = self.parse_current_params(current_options)

            # å¤„ç†å‰ç½®å‚æ•°
            prefix_config = game_config.get("prefix", {})
            final_prefix = self.merge_prefix_params(
                user_prefix,
                prefix_config,
                prefix_config.get("user_handling", {}),
                prefix_config.get("conflicts", {}),
            )

            # å¤„ç†åç½®å‚æ•°
            suffix_config = game_config.get("suffix", {})
            final_suffix = self.merge_suffix_params(
                user_suffix,
                suffix_config,
                suffix_config.get("user_handling", {}),
                suffix_config.get("conflicts", {}),
            )

            # æ„å»ºæœ€ç»ˆå‚æ•°
            if final_prefix and final_suffix:
                new_options = f"{' '.join(final_prefix)} %command% {final_suffix}"
            elif final_prefix:
                new_options = f"{' '.join(final_prefix)} %command%"
            elif final_suffix:
                new_options = f"%command% {final_suffix}"
            else:
                new_options = "%command%"

            # æ˜¾ç¤ºå˜æ›´
            if current_options != new_options:
                print(f"\nApp {app_id} ({game_config.get('name', 'Unknown')}):")
                print(f"  Before: {current_options or '(empty)'}")
                print(f"  After:  {new_options}")

                if not dry_run:
                    # åº”ç”¨æ›´æ”¹
                    if app_id not in apps:
                        apps[app_id] = {}
                    apps[app_id]["LaunchOptions"] = new_options

                    # ä¿å­˜æ–‡ä»¶
                    self.save_vdf_file(localconfig_path, data, vdf_format)

                    success = True
            else:
                print(f"App {app_id}: No changes needed")

        return success

    def backup_config(self, app_id, current_options):
        """å¤‡ä»½å½“å‰é…ç½®"""
        self.backup_dir.mkdir(parents=True, exist_ok=True)
        backup_file = (
            self.backup_dir
            / f"app_{app_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        )

        with open(backup_file, "w") as f:
            f.write(f"# Backup for Steam App {app_id}\n")
            f.write(f"# Created: {datetime.now()}\n")
            f.write("# Original launch options:\n")
            f.write(current_options or "(empty)")

    def apply_all_configs(self, dry_run=False):
        """åº”ç”¨æ‰€æœ‰æ¸¸æˆé…ç½®"""
        # åˆå¹¶ç”¨æˆ·é…ç½®å’Œç¤¾åŒºé…ç½®ä¸­çš„æ‰€æœ‰æ¸¸æˆ
        all_games = set()
        all_games.update(self.custom_config.get("games", {}).keys())
        all_games.update(self.community_config.get("games", {}).keys())

        if not all_games:
            print("No game configurations found")
            return

        print(f"Applying configurations for {len(all_games)} games...")
        if dry_run:
            print("DRY RUN MODE - No changes will be made")

        for app_id in all_games:
            if app_id.startswith("example_"):
                continue  # è·³è¿‡ç¤ºä¾‹é…ç½®
            self.apply_game_config(app_id, dry_run)

    def show_diff(self, app_id):
        """æ˜¾ç¤ºé…ç½®å·®å¼‚å¯¹æ¯”"""
        game_config, config_source = self.get_game_config(app_id)
        if not game_config:
            print(f"No config found for app {app_id}")
            return False

        print(
            f"Configuration diff for app {app_id} ({game_config.get('name', 'Unknown')}):"
        )
        print("=" * 60)

        for user_dir in self.get_steam_user_dirs():
            localconfig_path = user_dir / "config" / "localconfig.vdf"

            if not localconfig_path.exists():
                continue

            # è¯»å–å½“å‰é…ç½®
            data, vdf_format = self.load_vdf_file(localconfig_path)

            apps = (
                data.get("UserLocalConfigStore", {})
                .get("Software", {})
                .get("Valve", {})
                .get("Steam", {})
                .get("apps", {})
            )
            current_options = apps.get(app_id, {}).get("LaunchOptions", "")

            # è®¡ç®—æ–°é…ç½®
            user_prefix, user_suffix = self.parse_current_params(current_options)

            # å¤„ç†å‰ç½®å‚æ•°
            prefix_config = game_config.get("prefix", {})
            final_prefix = self.merge_prefix_params(
                user_prefix,
                prefix_config,
                prefix_config.get("user_handling", {}),
                prefix_config.get("conflicts", {}),
            )

            # å¤„ç†åç½®å‚æ•°
            suffix_config = game_config.get("suffix", {})
            final_suffix = self.merge_suffix_params(
                user_suffix,
                suffix_config,
                suffix_config.get("user_handling", {}),
                suffix_config.get("conflicts", {}),
            )

            # æ„å»ºæœ€ç»ˆå‚æ•°
            if final_prefix and final_suffix:
                new_options = f"{' '.join(final_prefix)} %command% {final_suffix}"
            elif final_prefix:
                new_options = f"{' '.join(final_prefix)} %command%"
            elif final_suffix:
                new_options = f"%command% {final_suffix}"
            else:
                new_options = "%command%"

            # æ˜¾ç¤ºè¯¦ç»†å·®å¼‚
            print("\nğŸ“‹ Current configuration:")
            print(f"   {current_options or '(empty)'}")

            print("\nğŸ¯ Proposed configuration:")
            print(f"   {new_options}")

            if current_options != new_options:
                print("\nğŸ”„ Changes:")

                # åˆ†æå…·ä½“å˜åŒ–
                if not current_options:
                    print(f"   + Will add: {new_options}")
                elif new_options == "%command%":
                    print("   - Will remove all launch options")
                else:
                    # è§£æå½“å‰å’Œæ–°çš„å‚æ•°è¿›è¡Œè¯¦ç»†å¯¹æ¯”
                    curr_prefix, curr_suffix = self.parse_current_params(
                        current_options
                    )
                    new_prefix, new_suffix = self.parse_current_params(new_options)

                    if curr_prefix != new_prefix:
                        print("   ğŸ“¦ Environment variables:")
                        if curr_prefix:
                            print(f"      - Current: {' '.join(curr_prefix)}")
                        else:
                            print("      - Current: (none)")
                        if new_prefix:
                            print(f"      + Proposed: {' '.join(new_prefix)}")
                        else:
                            print("      + Proposed: (none)")

                    if curr_suffix != new_suffix:
                        print("   ğŸš€ Launch parameters:")
                        if curr_suffix:
                            print(f"      - Current: {curr_suffix}")
                        else:
                            print("      - Current: (none)")
                        if new_suffix:
                            print(f"      + Proposed: {new_suffix}")
                        else:
                            print("      + Proposed: (none)")
            else:
                print("\nâœ… No changes needed - configuration is already up to date")

            print("\n" + "=" * 60)
            return True

        return False

    def validate_config(self):
        """éªŒè¯é…ç½®æ–‡ä»¶"""
        print("Validating configuration...")

        issues = []

        # éªŒè¯ç”¨æˆ·é…ç½®
        custom_games = self.custom_config.get("games", {})
        for app_id, game_config in custom_games.items():
            if not app_id.isdigit() and not app_id.startswith("example_"):
                issues.append(f"Custom config - App ID '{app_id}' should be numeric")

            # æ£€æŸ¥å¿…éœ€å­—æ®µ
            if "prefix" not in game_config and "suffix" not in game_config:
                issues.append(
                    f"Custom config - App {app_id}: No prefix or suffix configuration"
                )

        # éªŒè¯ç¤¾åŒºé…ç½®ï¼ˆåªæ£€æŸ¥æ ¼å¼ï¼Œä¸æ£€æŸ¥å†…å®¹ï¼‰
        community_games = self.community_config.get("games", {})
        print(
            f"Found {len(custom_games)} custom configs and {len(community_games)} community configs"
        )

        if issues:
            print("Configuration issues found:")
            for issue in issues:
                print(f"  - {issue}")
        else:
            print("Configuration is valid!")

    def update_community_db(self):
        """æ‰‹åŠ¨æ›´æ–°ç¤¾åŒºæ•°æ®åº“"""
        print("Manually updating community database...")
        self.force_update_community_db()
        print("Update completed!")


def main():
    parser = argparse.ArgumentParser(description="Steam Launch Options Manager")
    parser.add_argument(
        "command",
        choices=[
            "apply",
            "apply-all",
            "dry-run",
            "diff",
            "validate",
            "init",
            "update-db",
        ],
        help="Command to execute",
    )
    parser.add_argument("app_id", nargs="?", help="Steam App ID")
    parser.add_argument(
        "--config",
        default="~/.config/steam-launch-manager",
        help="Configuration file path",
    )
    parser.add_argument(
        "--dry-run", action="store_true", help="Preview changes without applying"
    )

    args = parser.parse_args()

    if args.command == "init":
        # åˆ›å»ºå¯¹è±¡æ—¶ä¼šè‡ªåŠ¨åˆå§‹åŒ–ç›®å½•å’Œé…ç½®æ–‡ä»¶
        manager = SteamLaunchManager(args.config)
        print("Configuration file created/updated")
        return

    manager = SteamLaunchManager(args.config)

    if args.command == "update-db":
        manager.update_community_db()
        return

    if args.command == "validate":
        manager.validate_config()
        return

    if args.command == "apply-all":
        manager.apply_all_configs(dry_run=args.dry_run)
        return

    if not args.app_id:
        print("App ID is required for this command")
        return

    if args.command == "apply":
        manager.apply_game_config(args.app_id, dry_run=args.dry_run)
    elif args.command == "dry-run":
        manager.apply_game_config(args.app_id, dry_run=True)
    elif args.command == "diff":
        manager.show_diff(args.app_id)


if __name__ == "__main__":
    main()
